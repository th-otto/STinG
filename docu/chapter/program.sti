@node "Programming with STinG"
@next "The Client Startup Code"
@prev "Programming with STinG"
Programming with STinG                                             STinG
@line 1 72 0 0 7

This section comprises information on how additional software for STinG
can be written. Additional software may be net clients and servers, but
STX modules too. Clients and servers are the same class of applications
from STinG's point of view, they may make use of the first collection of
function managers (see below). STX modules may use supplementary calls
from the second set of managers.

If you want to start writing software, you are strongly encouraged to
contact the STinG developers mailing group, the address being

            stik@@on-luebeck.de

Here you'll get additional information, skeleton source code, debugging
tools and can discuss various STinG related topics with other people.

The STinG @{"API" LINK "API"} can be reached via the STinG cookie. If STinG is installed
then a cookie with the name "STiK" is present, it's value is a pointer to
the @{"DRV_LIST" LINK "DRV_LIST"} structure, that contains a few more pointers providing access
to the @{"API" LINK "API"}. There is some magic string that must be checked, and a pointer
`get dftab' to a function that returns another pointer to the @{"API" LINK "API"} struc-
tures. To that end a pointer to a string must be passed, the latter being
either "TRANSPORT_TCPIP" or "MODULE_LAYER". Client authors should use the
@{"code excerpt" LINK "The Client Startup Code"} shown here to initialise.

The various functions of the STinG @{"API" LINK "API"} are arranged in groups that are
called @{B}Managers@{b}. Here is which managers are available from STinG.

The first collection is declared in TRANSPRT.H. It contains all the calls
that might be needed for any program using STinG services. The functions
are grouped to a structure, a pointer to which can be obtained by calling
get_dftab ("TRANSPORT_TCPIP") :

                    The @{"Memory Manager" LINK "The System Memory Manager"}
                    The @{"TCP Manager" LINK "The TCP Manager"}
                    The @{"UDP Manager" LINK "The UDP Manager"}
                    The @{"ICMP Manager" LINK "The ICMP Manager"}
                    The @{"Connection Manager" LINK "The Connection Manager"}
                    The @{"Port Manager" LINK "The Port Manager"}
                    The @{"Miscellaneous Manager" LINK "The Miscellaneous Manager"}
                    The @{"Dummy Manager" LINK "The Dummy Manager"}


The second assembly is declared in both PORT.H and LAYER.H. These calls
should only be used by STX modules. They are grouped to a structure, a
pointer to which is returned by get_dftab ("MODULE_LAYER") :

                    The @{"System Manager" LINK "The System Manager"}
                    The @{"IP Manager" LINK "The IP Manager"}
                    The @{"Protocol Manager" LINK "The Protocol Manager"}
                    The @{"Timing Manager" LINK "The Timing Manager"}
                    The @{"Routing Manager" LINK "The Routing Manager"}

A table showing all possible @{"error codes" LINK "STinG Error Codes"} is provided too.

STinG uses internally a protection mechanism that is based on the CPU's
privilege violation exception. Some development packages, debuggers and
memory monitors interfere with it, if they're not started from the AUTO
folder @{B}before@{b} STinG. Eabe Kuik developed a @{"patch for the Pure C" LINK "Pure C Patch Instructions"} develop-
ment package to get around this problem.

@endnode


@pnode "API"
The acronym API means @{B}Application Programming Interface@{b}.
It refers to a collection of all services that are provided
for programming applications. It comprises mainly calls, but
also variables, structures, etc.
@endnode


@pnode "DRV_LIST"
typedef struct drv_list {
    char      magic[10];
    DRV_HDR * cdecl (*get_dftab) (char *string);
    int16     cdecl (*ETM_exec) (char *string);
    void      *cfg;
    BASPAG    *sting_basepage;
} DRV_LIST;
@endnode


@node "The Client Startup Code"
@prev "Programming with STinG"
The Client Startup Code                                            STinG
@line 1 72 0 0 7

Some example code shows how a client initialises the STinG @{"API" LINK "API"} related
variables. It is strongly suggested to follow a similar scheme in your
own client. If you want to access the @{"API" LINK "API"} in other source code modules
too, you need to export the `tpl' variable to those modules :

@line 1 72 0 0 7

#include <stdio.h>
#include <tos.h>
#include <transprt.h>

DRV_LIST  *sting_drivers;
TPL       *tpl;


int main (void)
{
   switch (sting_init())
   {
   case -3 :
        puts ("STinG not loaded !");
        return 1;
   case -2 :
        puts ("STinG structures corrupted !");
        return 1;
   case -1 :
        puts ("No transport layer !");
        return 1;
   }
   /* Insert client code here, with access to all client @{"API" LINK "API"} calls */

   return 0;
}


int sting_init (void)
{
    sting_drivers = (DRV_LIST *) Supexec (get_sting_cookie);

    if (sting_drivers == NULL)
        return -3;
    if (strcmp (sting_drivers->magic, MAGIC) != 0)
        return -2;

    tpl = (TPL *) (*sting_drivers->get_dftab) (TRANSPORT_DRIVER);

    if  (tpl == (TPL *) NULL)
        return -1;

    return 0;
}


long get_sting_cookie (void)
{
    long  *work;

    work = * (long **) 0x5a0L;
    if (work == 0)
        return 0;
    for (; *work != 0; work += 2)
        if  (*work == 'STiK')
            return *++work;

    return 0;
}

@endnode


@node "The System Memory Manager"
@next "The `KRmalloc' Function"
The System Memory Manager                                          STinG
@line 1 72 0 0 7

The System Memory Manager contains all those functions that are used to
deal with internal memory. Basically the code from @{"Kernighan & Ritchie" LINK "Kernighan and Ritchie"}
is used, but there are some minor differences. Morecore is never called.
The functions use a big block of memory that is allocated at boot time.
They are mainly for storing datagrams, receive and send queues, and in-
ternal structures that are created and destroyed by the interupt driven
IP core. Thus internal memory is a precious resource, and should not be
wasted. STinG clients should whenever possible use the normal TOS Malloc
and Mfree functions.

These calls are :

    void *  cdecl  @{"KRmalloc" LINK "The `KRmalloc' Function"} (int32);
    void    cdecl  @{"KRfree" LINK "The `KRfree' Function"} (void *);
    int32   cdecl  @{"KRgetfree" LINK "The `KRgetfree' Function"} (int16);
    void *  cdecl  @{"KRrealloc" LINK "The `KRrealloc' Function"} (void *, int32);
@endnode


@pnode "Kernighan and Ritchie"
This is the standard reference book for C programmers :

@{B}The C programming language@{b}
Brian W. Kernighan  and  Dennis M. Ritchie
(c) 1978 1988 by Bell Telephone Laboratories, Incorporated
(p) Prentice Hall International, New Jersey
@endnode


@node "The `KRmalloc' Function"
@symbol ar "KRmalloc"
@prev "The System Memory Manager"
The `KRmalloc' Function                                            STinG
@line 1 72 0 0 7


    void *  cdecl  KRmalloc (int32 length);


Function :
   Allocates system memory.


This function is used to allocate a chunk of memory for exclusive use by
the caller. The required length of the block is passed as the parameter.
The block must be freed again later, this will not automagically happen
on termination of the caller ! Use @{"KRfree" LINK "The `KRfree' Function"} with the address returned by
KRmalloc to achieve that.

Returns the address of the allocated block, or NULL if memory is low.

@endnode


@node "The `KRfree' Function"
@symbol ar "KRfree"
The `KRfree' Function                                              STinG
@line 1 72 0 0 7


    void  cdecl  KRfree (void *block);


Function :
   Frees a block of system memory.


This function is used to release blocks of system memory that have been
allocated via @{"KRmalloc" LINK "The `KRmalloc' Function"} or @{"KRrealloc" LINK "The `KRrealloc' Function"} before. Passing a NULL pointer does
not crash the system.

@endnode


@node "The `KRgetfree' Function"
@symbol ar "KRgetfree"
The `KRgetfree' Function                                           STinG
@line 1 72 0 0 7


    int32  cdecl  KRgetfree (int16 which);


Function :
   Returns the amount of free system memory.


This function is used to inquire about the space that is left in the in-
ternal memory. The parameter determines if the size of the largest block
(`which' is TRUE), or the total amount (FALSE) is returned.

@endnode


@node "The `KRrealloc' Function"
@symbol ar "KRrealloc"
The `KRrealloc' Function                                           STinG
@line 1 72 0 0 7


    void *  cdecl  KRrealloc (void *block, int32 new_length);


Function :
   Changes the size of an already allocated block of system memory.


This function changes the size of a block that has been allocated before
using @{"KRmalloc" LINK "The `KRmalloc' Function"}. The call tries to not move the block even if `new_length'
is larger than the old size. Sometimes this is not possible, the `block'
parameter will contain the new address in that case, and the contents will
be copied into the new block. If `new_length' is zero then the block will
be released as if @{"KRfree" LINK "The `KRfree' Function"} was called. With `block' containing NULL the call
behaves like @{"KRmalloc" LINK "The `KRmalloc' Function"}, but zeros the contents of the new block.

Returns the address of the new block.

@endnode


@node "The TCP Manager"
The TCP Manager                                                    STinG
@line 1 72 0 0 7

The @{"TCP" LINK "Transmission Control Protocol (TCP)"} Manager contains all those functions that are needed for all nor-
mal stream communication via the net. In addition to data transfer func-
tions, means for synchronizing with the other end of the connection are
provided.

Note that only dummy functions are available if TCP.STX is not loaded.

These calls are :

    int16  cdecl  @{"TCP_open" LINK "The `TCP_open' Function"} (uint32, uint16, uint16, uint16);
    int16  cdecl  @{"TCP_close" LINK "The `TCP_close' Function"} (int16, int16);
    int16  cdecl  @{"TCP_send" LINK "The `TCP_send' Function"} (int16, char *, int16);
    int16  cdecl  @{"TCP_wait_state" LINK "The `TCP_wait_state' Function"} (int16, int16, int16);
    int16  cdecl  @{"TCP_ack_wait" LINK "The `TCP_ack_wait' Function"} (int16, int16);
    int16  cdecl  @{"TCP_info" LINK "The `TCP_info' Function"} (int16, @{"TCPIB" LINK "The `TCPIB' Structure"} *);
@endnode


@node "The `TCP_open' Function"
@symbol ar "TCP_open"
The `TCP_open' Function                                            STinG
@line 1 72 0 0 7


    int16  cdecl  TCP_open (uint32 rem_host, uint16 rem_port, uint16 tos,
                            uint16 buffer_size);


Function :
   Opens a TCP connection in active or passive mode.


This function is used to set up a TCP communication endpoint. Depending
on the addressing parameters it either becomes a listening endpoint, or
a connection to some other listening endpoint is initiated.  Correspon-
dingly the endpoint can be set up in passive (listening) or active (ini-
tiating a connection) mode.  The mode and the endpoint(s) are specified
using the first two parameters (see below).  The parameter `tos' is the
@{"IP type of service" LINK "IP Type Of Service"} to be used during the connection,  and `buffer_size'
the size of the output buffer. For the latter,  about one to two kiloby-
tes should suffice in virtually all cases.

The addressing can be done using one of two possible schemes.  The first
scheme is completely STiK compatible, as the drawback it also shares the
restrictions found in STiK. Using the second scheme, full BSD functiona-
lity is provided, i.e. the full set of connection parameters can be spe-
cified. These are both port and IP address for both the local and remote
host.

For the STiK compatible way of addressing, the first parameter `rem_host'
specifies the (remote) IP address,  while the second parameter `rem_port'
is used to pass the port number. A connection is initiated now. There is
no provision to specify any local parameters. Passive opening is done by
specifying zero as the `rem_host',  the `rem_port' parameter becomes the
local port number now. Here, any incoming connection aimed for the speci-
fied port is accepted, there is no way to let STinG automatically reject
connections coming from hosts that are not authorized or coming from the
wrong remote port number.

The extended way of addressing  takes advantage of some unused port num-
bers,  by specifying some special meaning for their use as the `rem_port'
parameter.  If either TCP_ACTIVE or TCP_PASSIVE are passed as the second
parameter, the extended addressing scheme is employed. Now the `rem_port'
parameter just determines whether active or passive opening is intended,
and the first `rem_host' parameter is interpreted as a pointer to a @{"CAB" LINK "CAB"}
structure, which is used to specify any desired sub-set of the whole set
of local and remote host IP address and port number. Parameters that are
not needed to be specified, can be set to zero.  Remote host or port can
be left unspecified for passive endpoints, local IP address or port num-
ber are filled in automatically if not specified.

Note if some host connects to a passively opened endpoint,  the endpoint
will become an established connection. No other host can connect to this
endpoint anymore. If you need an opened endpoint all the time, then just
do another TCP_open,  or have several passive endpoints open at the same
time.

TCP_open does not wait for the connection to become established, but re-
turns immediately. The STinG @{"TCP_wait_state" LINK "The `TCP_wait_state' Function"} call can be used to wait for
an established connection. Another (probably more flexible) option is to
call @{"CNbyte_count" LINK "The `CNbyte_count' Function"} which will return E_LISTEN if a passive endpoint still
is in LISTEN mode. Still another option is to check out the info that is
pointed to by the pointer returned by @{"CNgetinfo" LINK "The `CNgetinfo' Function"}.


The above was the STiK compatible way of waiting for a connection to
be completed.  A better option for STinG-specific code is to directly
test the TCP state returned by @{"TCP_info" LINK "The `TCP_info' Function"} in a @{"TCPIB" LINK "The `TCPIB' Structure"} structure.


Returns a non-negative connection handle or a (negative) error code. The
error codes can be  E_UNREACHABLE  (there is no route to the destination
host, or the chain of physical links is interrupted),  E_PARAMETER  (for
an active endpoint no remote host is specified),  or  E_NOMEM  (required
memory could not be allocated).

Note that only a dummy function is available if TCP.STX is not loaded.
This dummy always returns E_UNREACHABLE.

@endnode


@node "The `TCP_close' Function"
@symbol ar "TCP_close"
The `TCP_close' Function                                           STinG
@line 1 72 0 0 7


    int16 cdecl TCP_close (int16 handle, int16 timemode, int16 *result);


Function :
   Closes a TCP connection.

This function has been redefined from STinG release 1.20 and onwards,
but the present implementation remains compatible even at binary level
with all clients and servers compiled with the older prototype.

For programmers that want to simply patch their source to be accepted
with the new prototype, without using new features:

The change you need to make is simply to add a new argument "NULL" as
the last argument in the list.  Then all still works as before.


The original STiK specification for TCP_close by Steve Adam is:

  - Closes a connection.  `handle' is the connection handle.
  - Returns 0 or a negative error code.
  - timemode is the time in seconds to wait for the connection to close.
    TCP_close() must negotiate the close with the remote host, so
    it can take some time if the net is slow.  Pending data may need
    to be received and discarded before the connection closes cleanly.
  - Note that TCP_close() *must* be called in order to free memory
    that has been allocated for the connection.
  - A timeout of 0 is acceptable for immediate close.
  - If the ESC key is pressed during the timeout period, TCP_close()
    returns immediately with a E_USERTIMEOUT error code.

STinG does not allow global use of ESC key, as defined by Steve, but
apart from that his definition is still valid for those cases where
'timemode' is a positive value (including zero).  That does mean it
is valid for all the values that STiK allowed.


If 'timemode' is -1 however, this means that the caller wants to let the
timeout proceed under interrupt control, so that the caller can continue
to work (in event loops etc) while that connection closes.  The caller
can still receive a return value, by passing a pointer in 'result'.
If that is not done, it means that the caller wants no result code.
For such cases the caller can then forget about that connection.

If a pointer is passed, that will be used by the interrupt routines to
store a final result code (usually E_NORMAL or E_CNTIMEOUT), either when
closing negotiation with the other end succeeds, or when a final timeout
is exceeded (fixed internally at 1000 seconds).

If a former caller, which did pass a pointer this way, decides it does
not want the value stored after all, then it must inform the interrupt
code of this.  That is done by making a new TCP_close call for the same
connection, but this time with a zero 'timemode' value, which will
cancel the pointer passed earlier.  The function then returns E_NORMAL
directly, and the caller can forget the connection, although closing
process still continues, but fully controlled by the interrupt code.


It remains legal to read data on connections after closing but not to
send data and, whenever the close negotiation completes, the handle
of the connection will be released as will all connection structures.
From that moment on all attempts to use that connection will return
E_BADHANDLE, as the connection is no longer even half open.
Half_open connenction is thus implemented as per RFC specs.


Note that only a dummy function is available if TCP.STX is not loaded.
This dummy always returns E_BADHANDLE.

@endnode


@node "The `TCP_send' Function"
@symbol ar "TCP_send"
The `TCP_send' Function                                            STinG
@line 1 72 0 0 7


    int16  cdecl  TCP_send (int16 handle, char *buffer, int16 length);


Function :
   Send off data via a TCP connection.


The function description is not available yet, since this function might
see an extension of it's specification soon. Here is the specification
by Steve Adam as a kludge :

  - Send `length' bytes from `buffer' on the connection `handle'.
  - Returns E_NORMAL for success, or an error code.
  - Note that the error E_OBUFFULL is *not* a fatal error.
    If E_OBUFFULL is return, you should loop, for your own timeout period,
    waiting for the output buffer to clear.  If you have defined a buffer
    that is smaller than the block you are sending, it will never clear.

Note that only a dummy function is available if TCP.STX is not loaded.
This dummy always returns E_BADHANDLE.

@endnode


@node "The `TCP_wait_state' Function"
@symbol ar "TCP_wait_state"
The `TCP_wait_state' Function                                      STinG
@line 1 72 0 0 7


    int16  cdecl  TCP_wait_state (int16 handle, int16 state, int16 timeout);


Function :
   Wait for a TCP connection to enter a specific state.


This function waits until the TCP connection `handle' enters the TCP state
`state', which can be any from the whole set  TCLOSED, TLISTEN, TSYN_SENT,
TSYN_RECV,  TESTABLISH,  TFIN_WAIT1,  TFIN_WAIT2,  TCLOSE_WAIT,  TCLOSING,
TLAST_ACK or TTIME_WAIT. Note specifying some of the mentioned states does
not make any sense, as they cannot be reached directly. `timeout' specifies
a delay in seconds after which the call returns in any case, regardless if
the desired state has been entered or not.

The TCP_wait_state calls _appl_yield internally so that GEM AES will still
cooperatively multitask while the function is waiting.

Returns E_NORMAL, or E_BADHANDLE, E_CNTIMEOUT, E_UNREACHABLE, E_CONNECTFAIL,
E_REFUSE or E_RRESET.


Note that for STinG-specific programs this function is now redundant, as
the @{"TCP_info" LINK "The `TCP_info' Function"} function can return the current TCP state at each call, and
will then do so without any delay whatsoever. That permits smart clients
to do other useful work (event loops etc) while awaiting pecific states.
This makes clients using @{"TCP_info" LINK "The `TCP_info' Function"} better than those using TCP_wait_state,
by allowing them to do more things in parallel, and also allows a client
to test for many different states, not just one.


Note that only a dummy function is available if TCP.STX is not loaded.
This dummy always returns E_BADHANDLE.

@endnode


@node "The `TCP_ack_wait' Function"
@symbol ar "TCP_ack_wait"
The `TCP_ack_wait' Function                                        STinG
@line 1 72 0 0 7


    int16  cdecl  TCP_ack_wait (int16 handle, int16 timeout);


Function :
   Wait for all send data on a TCP connection to become acknowledged.


This function waits until on the specified connection all buffered out-
going data is acknowledged by the remote host. The `timeout' parameter
specifies a delay in milliseconds, after which the call returns in any
case, regardless if all data has been acknowledged or not.

The TCP_ack_wait calls _appl_yield internally so that GEM AES will still
cooperatively multitask while the function is waiting.

Returns E_NORMAL, or E_BADHANDLE, E_CNTIMEOUT, E_UNREACHABLE, E_REFUSE,
E_CONNECTFAIL or E_RRESET.


Note that for STinG-specific programs this function is now redundant, as
the @{"TCP_info" LINK "The `TCP_info' Function"} function can return the number of unacknowledged sequence
positions sent on the connection (incl SYN/FIN bits). It will do so with
no delay whatsoever. That permits smart clients to do other useful work
(event loops etc) while awaiting acknowledgments for data sent.  This
will make clients using @{"TCP_info" LINK "The `TCP_info' Function"} better than those using TCP_ack_wait,
by allowing them to do more things in parallel.


Note that only a dummy function is available if TCP.STX is not loaded.
This dummy always returns E_BADHANDLE.

@endnode


@node "The `TCP_info' Function"
@symbol ar "TCP_info"
The `TCP_info' Function                                            STinG
@line 1 72 0 0 7


    int16  cdecl  TCP_info (int16 handle, @{"TCPIB" LINK "The `TCPIB' Structure"} *buffer);


Function :
   Read or set special TCP information not available elsewhere.


This function was invented to avoid adding new functions to the @{"API" LINK "API"} for
'odd jobs', which nevertheless are extremely useful to some clients.
The 'buffer' parameter should be set to a buffer that is owned by the
caller, and which has space needed for all the data the caller is going
to request as reply.  It is up to the calling code to allocate the RAM
of this buffer in whatever way it pleases, and likewise to release it
again when no longer needed.  Using static RAM arrays for such buffers
is also legal, and then no special release will be necessary.

One vital use of this function is to switch a connection to DEFER mode.
That is needed to use the @{"API" LINK "API"} freely from interrupts and TOS function
dispatchers, which is needed for some special servers and clients.

Unlike @{"CIB" LINK "The `CIB' Structure"} buffers, a @{"TCPIB" LINK "The `TCPIB' Structure"} buffer only receives data from the TCP
module each time TCP_info is called for that buffer, and according
to the request data then stored in the first uint32 of it. For more
details on how to use it, read specification of the @{"TCPIB" LINK "The `TCPIB' Structure"} structure.

@endnode


@node "The `TCPIB' Structure"
@symbol ar "TCPIB"
The `TCPIB' Structure                                              STinG
@line 1 72 0 0 7

Structure used by @{"TCP_info" LINK "The `TCP_info' Function"} to fetch or set special TCP info for things
which the normal @{"API" LINK "API"} functions can not handle. There is also a similar
structure named @{"UDPIB" LINK "The `UDPIB' Structure"}, documented separately, doing the same for UDP.

typedef struct tcpib
{   uint32  request;  /* 32 bits requesting various info (following) */
    uint16  state;    /* current TCP state                           */
    uint32  unacked;  /* unacked outgoing seq_length (incl SYN/FIN)  */
    uint32  srtt;     /* smoothed round trip time of connection      */
}   TCPIB;

Only those info values specified by the 'request' element will be filled
in with data during a @{"TCP_info" LINK "The `TCP_info' Function"} call.

The four values defined below are bit values for the 'request element.
For combined requests the sum of the relevant values should be used.

#define TCPI_state      1L  /* request current TCP state             */
#define TCPI_unacked    2L  /* request length of unacked sequence    */
#define TCPI_srtt       4L  /* request smoothed round trip time      */
#define TCPI_defer      8L  /* request switch to DEFER mode          */

Note that TCPI_defer does not specify info to be fetched, but is used to
switch a connection into DEFER mode.  Such a switch is permanent, so the
effect will last until the connection has been closed, but of course, it
does not affect any other connections not switched to this mode.

In DEFER mode no TCP function will loop internally to await any result.
Instead they will return directly for such cases, and will then return
the error code E_LOCKED.  That means that no real error has occurred,
but the function could not be completed right away.  Correct response
to this is to call again at some later time. For interrupt driven code
that normally means doing it in some future interrupt event.

The purpose of DEFER mode is to prevent interrupt driven servers from
locking up the system, and to allow all @{"API" LINK "API"} calls to be made from any
runtime environment, including both interrupts and GEMDOS dispatcher.
(The latter is needed for networked filesystem and device drivers.)

@endnode


@node "The UDP Manager"
The UDP Manager                                                    STinG
@line 1 72 0 0 7

The @{"UDP" LINK "User Datagram Protocol (UDP)"} Manager contains all those functions that are required for basic
datagram traffic. This is basically the IP interface for user applica-
tions.

Note that only dummy functions are available if UDP.STX is not loaded.

These calls are :

    int16  cdecl  @{"UDP_open" LINK "The `UDP_open' Function"} (uint32, uint16);
    int16  cdecl  @{"UDP_close" LINK "The `UDP_close' Function"} (int16);
    int16  cdecl  @{"UDP_send" LINK "The `UDP_send' Function"} (int16, char *, int16);
    int16  cdecl  @{"UDP_info" LINK "The `UDP_info' Function"} (int16, @{"UDPIB" LINK "The `UDPIB' Structure"} *);
@endnode


@node "The `UDP_open' Function"
@symbol ar "UDP_open"
The `UDP_open' Function                                            STinG
@line 1 72 0 0 7


    int16  cdecl  UDP_open (uint32 rem_host, uint16 rem_port);


Function :
   Opens a UDP pseudo connection.


This function is used to set up a UDP communication endpoint. Addressing
can be done using one of two possible schemes.  The first scheme is com-
pletely STiK compatible, as the drawback it also shares the restrictions
found in STiK. Using the second scheme, full BSD functionality is provi-
ded, i.e. the full set of connection parameters can be specified.  These
are both port and IP address for both the local and remote host.

With the STiK compatible way of addressing, either remote or local para-
meters can be specified, but not both. For specifying remote parameters,
the IP address and the port number are passed as the two parameters. For
local parameters,  the IP address cannot be set,  since passing of local
parameters is indicated  by passing zero for the  first `rem_host' para-
meter. In this case, `rem_port' specifies the local port number, and any
remote host can send data to this endpoint from any remote port number.

The extended way of addressing  takes advantage of some unused port num-
bers,  by specifying some special meaning for their use as the `rem_port'
parameter. If UDP_EXTEND is passed as the second parameter, the extended
addressing scheme is employed.  The first parameter is interpreted as a
pointer to a @{"CAB" LINK "CAB"} structure, which is used to specify any desired sub-set
of the complete set of local and remote host IP address and port number.
Parameters that are not needed to be specified, can be set to zero.  The
remote host or port can be left unspecified for passive endpoints, local
IP address or port number are filled in automatically if not specified.

Note if some host sends data to a only partially specified endpoint, the
endpoint will become an established (fully specified) pseudo connection.
No other host can send data to this endpoint anymore. If you need opened
endpoints all the time,  then just do another UDP_open,  or have several
passive endpoints open at the same time.

UDP_open does not wait for the endpoint to become fully specified,  but
returns immediately.  You need to call @{"CNgetinfo" LINK "The `CNgetinfo' Function"} and check the info the
returned pointer points to, in order to find out if the endpoint became
fully specified in the meantime.


The above was one STiK compatible way of waiting for a connection to
be specified.  A better option for STinG-specific code is to directly
test the UDP pseudo state returned by @{"UDP_info" LINK "The `UDP_info' Function"} in a @{"UDPIB" LINK "The `UDPIB' Structure"} structure.


Returns a non-negative connection handle or a (negative) error code. The
error codes can be  E_UNREACHABLE  (there is no route to the destination
host or the chain of physical links is interrupted) or E_NOMEM (required
memory could not be allocated).

Note that only a dummy function is available if UDP.STX is not loaded.
This dummy always returns E_UNREACHABLE.

@endnode


@node "The `UDP_close' Function"
@symbol ar "UDP_close"
The `UDP_close' Function                                           STinG
@line 1 72 0 0 7


    int16  cdecl  UDP_close (int16 handle);


Function :
   Closes a UDP pseudo connection.


After a UDP communication endpoint has been opened by @{"UDP_open" LINK "The `UDP_open' Function"}, and used
by @{"UDP_send" LINK "The `UDP_send' Function"} and the @{"CN* calls" LINK "The Connection Manager"}, it MUST be closed afterwards when it's not
needed anymore. Failure to do so will cause the associated handle to re-
main permanently blocked. Although there are plenty of handles available,
repeated failure will first slow down the system, and eventually cause it
to run out of handles. This must be avoided under all circumstances.

The only parameter to this call is the pseudo connection handle that has
been returned by @{"UDP_open" LINK "The `UDP_open' Function"}. The UDP_close call returns immediately.

Returns E_NORMAL, or E_BADHANDLE if the passed handle is invalid.

Note that only a dummy function is available if UDP.STX is not loaded.
This dummy always returns E_BADHANDLE.

@endnode


@node "The `UDP_send' Function"
@symbol ar "UDP_send"
The `UDP_send' Function                                            STinG
@line 1 72 0 0 7


    int16  cdecl  UDP_send (int16 handle, char *buffer, int16 length);


Function :
   Send off data via a UDP pseudo connection.


A block of data which is described by the memory address (passed in the
`buffer' parameter) and the amount (passed in `length') is send away as
a single datagram to the host and the port specified via the @{"UDP_open" LINK "The `UDP_open' Function"}
call that returned the pseudo connection handle `handle'. Fragmentation
and reassembly will happen as required. This is completely transparent
to the calling application.

Returns E_NORMAL, or E_BADHANDLE (passed handle is invalid),  E_LISTEN
(pseudo connection not fully specified yet), E_NOMEM (allocating memory
failed). For network errors, E_UNREACHABLE, E_CNTIMEOUT and E_TTLEXCEED
are returned.

Note that only a dummy function is available if UDP.STX is not loaded.
This dummy always returns E_BADHANDLE.

@endnode


@node "The `UDP_info' Function"
@symbol ar "UDP_info"
The `UDP_info' Function                                            STinG
@line 1 72 0 0 7


    int16  cdecl  UDP_info (int16 handle, @{"UDPIB" LINK "The `UDPIB' Structure"} *buffer);


Function :
   Read or set special UDP information not available elsewhere.


This function was invented to avoid adding new functions to the @{"API" LINK "API"} for
'odd jobs', which nevertheless are extremely useful to some clients.
The 'buffer' parameter should be set to a buffer that is owned by the
caller, and which has space needed for all the data the caller is going
to request as reply.  It is up to the calling code to allocate the RAM
of this buffer in whatever way it pleases, and likewise to release it
again when no longer needed.  Using static RAM arrays for such buffers
is also legal, and then no special release will be necessary.

One vital use of this function is to switch a connection to DEFER mode.
That is needed to use the @{"API" LINK "API"} freely from interrupts and TOS function
dispatchers, which is needed for some special servers and clients.

Unlike @{"CIB" LINK "The `CIB' Structure"} buffers, a @{"UDPIB" LINK "The `UDPIB' Structure"} buffer only receives data from the UDP
module each time UDP_info is called for that buffer, and according
to the request data then stored in the first uint32 of it. For more
details on how to use it, read specification of the @{"UDPIB" LINK "The `UDPIB' Structure"} structure.

@endnode


@node "The `UDPIB' Structure"
@symbol ar "UDPIB"
The `UDPIB' Structure                                              STinG
@line 1 72 0 0 7

Structure used by @{"UDP_info" LINK "The `UDP_info' Function"} to fetch or set special UDP info for things
which the normal @{"API" LINK "API"} functions can not handle. This roughly corresponds
to the @{"TCPIB" LINK "The `TCPIB' Structure"} structure and is intended for similar uses for UDP.

typedef struct udpib
{   uint32  request;  /* 32 bits requesting various info (following) */
    uint16  state;    /* current UDP pseudo state                    */
    uint32  reserve1; /* reserved */
    uint32  reserve2;     /* reserved */
}   UDPIB;

Only those info values specified by the 'request' element will be filled
in with data during a @{"UDP_info" LINK "The `UDP_info' Function"} call.

The four values defined below are bit values for the 'request element.
For combined requests the sum of the relevant values should be used.

#define UDPI_state      1L  /* request current UDP pseudo state      */
#define UDPI_reserve1   2L  /* reserved */
#define UDPI_reserve2   4L  /* reserved */
#define UDPI_defer      8L  /* request switch to DEFER mode          */

Note that UDPI_defer does not specify info to be fetched, but is used to
switch a connection into DEFER mode.  Such a switch is permanent, so the
effect will last until the connection has been closed, but of course, it
does not affect any other connections not switched to this mode.

In DEFER mode no UDP function will loop internally to await any result.
Instead they will return directly for such cases, and will then return
the error code E_LOCKED.  That means that no real error has occurred,
but the function could not be completed right away.  Correct response
to this is to call again at some later time. For interrupt driven code
that normally means doing it in some future interrupt event.

The purpose of DEFER mode is to prevent interrupt driven servers from
locking up the system, and to allow all @{"API" LINK "API"} calls to be made from any
runtime environment, including both interrupts and GEMDOS dispatcher.
(The latter is needed for networked filesystem and device drivers.)

@endnode


@node "The ICMP Manager"
The ICMP Manager                                                   STinG
@line 1 72 0 0 7

The ICMP Manager contains all those functions that are required when @{"ICMP" LINK "Internet Control Message Protocol (ICMP)"}
functionality is to be utilized. As ICMP datagrams must be handled with
priority, a callback scheme is employed for processing arriving datagrams.

These calls are :

    int16  cdecl  @{"ICMP_send" LINK "The `ICMP_send' Function"} (uint32, uint8, uint8, void *, uint16);
    int16  cdecl  @{"ICMP_handler" LINK "The `ICMP_handler' Function"} (int16 cdecl (*) (IP_DGRAM *), int16);
    void   cdecl  @{"ICMP_discard" LINK "The `ICMP_discard' Function"} (IP_DGRAM *datagram);
@endnode


@node "The `ICMP_send' Function"
@symbol ar "ICMP_send"
The `ICMP_send' Function                                           STinG
@line 1 72 0 0 7


    int16  cdecl  ICMP_send (uint32 dest_host, uint8 type, uint8 code,
                             void *data, uint16 length);


Function :
   Send off ICMP datagrams.


This function sends an ICMP message. `dest_host' is the IP address of the
destination machine, `type' is the ICMP packet type. `code' is a type de-
pendent control code for ICMP. `data' is a pointer to data which is to be
send after the ICMP header, `length' is the length of the data block in
bytes.

Note that after calling this function the calling code keeps ownership of
the data block.

Returns E_BADDNAME, E_PARAMETER, E_NOMEM or E_NORMAL.

@endnode


@node "The `ICMP_handler' Function"
@symbol ar "ICMP_handler"
The `ICMP_handler' Function                                        STinG
@line 1 72 0 0 7


    int16  cdecl  ICMP_handler (int16 cdecl (* handler) (IP_DGRAM *),
                                int16 install_code);


Function :
   Install and deinstall handlers for ICMP datagrams.


A handler function for dealing immediately with incoming ICMP datagrams
can be installed using this call. The handler will be called for each
ICMP datagram that comes in, regardless whether it is bound for the
calling application, or not. The handler has to check for that. If the
datagram is not of interest for the calling application, the handler
must return FALSE ! Otherwise the handler should process the datagram
and return TRUE. It must also discard the datagram in this case via the
@{"ICMP_discard" LINK "The `ICMP_discard' Function"} call.

Note that some types of ICMP datagrams are processed internally and thus
are never passed to any installed handlers.

The installed function is called from the main interupt, thus may use
only a very limited amount of CPU time. Hence waiting for any event is
not allowed. The call is done asynchronously in Supervisor mode, thus
care must be execised with using any operating system call within the
handler function.

The `install code' can be

   HNDLR_SET :
   HNDLR_FORCE :
        Unlike @{"IP_handler" LINK "The `IP_handler' Function"}, with ICMP_handler these codes have the same
        meaning. They install another ICMP handler callback function.
        Returns TRUE, if successfull, and FALSE, if there was a memory
        problem, or the function has been installed before.

   HNDLR_REMOVE :
        Declare a handler, that has been installed earlier, as invalid.
        This handler won't be called anymore. This must be done when a
        program that installed a handler, terminates. Returns FALSE if
        the specified handler was not installed.

   HNDLR_QUERY :
        Inquire whether the specified handler is installed, without
        changing it. Returns TRUE if it is there, and FALSE, if not.

@endnode


@node "The `ICMP_discard' Function"
@symbol ar "ICMP_discard"
The `ICMP_discard' Function                                        STinG
@line 1 72 0 0 7


    void  cdecl  ICMP_discard (IP_DGRAM *datagram);


Function :
   Discards an ICMP datagram.


An ICMP datagram processed by a handler function must be discarded after-
wards. This call provides the means for it. In the current implementation
this call is identical to @{"IP_discard" LINK "The `IP_discard' Function"} (datagram, TRUE);.

@endnode


@node "The Connection Manager"
The Connection Manager                                             STinG
@line 1 72 0 0 7

The Connection Manager contains all those functions that are provided by
high level protocols, such as TCP and UDP, to receive data by a client.
Functions to receive single bytes or whole chunks of data are there, and
to inquire about connection parameters.

These calls are :

    int16  cdecl  @{"CNkick" LINK "The `CNkick' Function"} (int16);
    int16  cdecl  @{"CNbyte_count" LINK "The `CNbyte_count' Function"} (int16);
    int16  cdecl  @{"CNget_char" LINK "The `CNget_char' Function"} (int16);
    NDB *  cdecl  @{"CNget_NDB" LINK "The `CNget_NDB' Function"} (int16);
    int16  cdecl  @{"CNget_block" LINK "The `CNget_block' Function"} (int16, char *, int16);
    @{"CIB" LINK "The `CIB' Structure"} *  cdecl  @{"CNgetinfo" LINK "The `CNgetinfo' Function"} (int16);
    int16  cdecl  @{"CNgets" LINK "The `CNgets' Function"} (int16, uint8 *, int16, uint8);
    void   cdecl  @{"CNfree_NDB" LINK "The `CNfree_NDB' Function"} (int16, @{"NDB" LINK "NDB"} *);
@endnode


@node "The `CNkick' Function"
@symbol ar "CNkick"
The `CNkick' Function                                              STinG
@line 1 72 0 0 7


    int16  cdecl  CNkick (int16 handle);


Function :
   Kick a connection.


Protocols that carefully implement flow control mechanisms can be easily
hindered by unreliable data paths. If acknowledgement datagrams get lost,
under some circumstances it can take a little while until retransmission
sets in and another acknowledgement datagram is sent.  This function can
be used to enforce immediate transmission of an acknowledgement and data
that is waiting for getting acknowledged.

As TCP is carefully designed to work best even under weird circumstances,
this function should be used with utter care ! Excessive usage of CNkick
must be avoided !  Called on UDP pseudo connections, this functions does
nothing.

Returns E_NORMAL if successful.

Generic TCP / UDP errors returned are E_LISTEN, E_EOF, E_NODATA, E_REFUSE,
E_CONNECTFAIL or E_RRESET. For network errors, E_UNREACHABLE, E_CNTIMEOUT
and E_TTLEXCEED are returned.

@endnode


@node "The `CNbyte_count' Function"
@symbol ar "CNbyte_count"
The `CNbyte_count' Function                                        STinG
@line 1 72 0 0 7


    int16  cdecl  CNbyte_count (int16 handle);


Function :
   Inquires about the number of received bytes pending.


On any TCP connection or UDP pseudo connection this call can be used for
inquiring how many bytes have arrived in the input buffers. The returned
number of bytes can be fetched immediately using any of the other recep-
tion calls @{"CNget_char" LINK "The `CNget_char' Function"}, @{"CNget_NDB" LINK "The `CNget_NDB' Function"}, @{"CNget_block" LINK "The `CNget_block' Function"} or @{"CNgets" LINK "The `CNgets' Function"}.

Returns the number of bytes pending for reception, if successful.

Generic TCP / UDP errors returned are E_LISTEN, E_EOF, E_NODATA, E_REFUSE,
E_CONNECTFAIL or E_RRESET. For network errors, E_UNREACHABLE, E_CNTIMEOUT
and E_TTLEXCEED are returned.

Note : Return values of zero and E_NODATA are equivalent, and not fatal.

@endnode


@node "The `CNget_char' Function"
@symbol ar "CNget_char"
The `CNget_char' Function                                          STinG
@line 1 72 0 0 7


    int16  cdecl  CNget_char (int16 handle);


Function :
   Fetch a received character or byte from a connection.


This function fetches a single character or byte from the input queue of
the TCP connection or UDP pseudo connection specified by `handle'.

Returns the received byte (lower byte of 16 bit word) if successful.

Generic TCP / UDP errors returned are E_LISTEN, E_EOF, E_NODATA, E_REFUSE,
E_CONNECTFAIL or E_RRESET. For network errors, E_UNREACHABLE, E_CNTIMEOUT
and E_TTLEXCEED are returned.

@endnode


@node "The `CNget_NDB' Function"
@symbol ar "CNget_NDB"
@next "The `CNget_block' Function"
The `CNget_NDB' Function                                           STinG
@line 1 72 0 0 7


    NDB *  cdecl  CNget_NDB (int16 handle);


Function :
   Fetch a received chunk of data from a connection.


This function retrieves a whole block of data from the input queue of the
TCP connection or UDP pseudo connection specified by `handle'. These data
blocks correspond to incoming datagrams. Hence this call is most probably
the best way to receive UDP datagrams, but it provides the most efficient
way to retrieve incoming data for TCP connections too.

The function returns a pointer to a @{"Network Data Block" LINK "NDB"}. The structure and
the associated data are @{"KRmalloc" LINK "The `KRmalloc' Function"}'d blocks, for which the calling applica-
tion is responsible now (must call @{"KRfree" LINK "The `KRfree' Function"} with each of them).  The struc-
ture contains the address of the data (`ndata')  as well as the number of
valid bytes (`len') as entries.  The following C code is a guide on how a
@{"NDB" LINK "NDB"} should be handled :

@line 3 62 0 0 7

     NDB  *ndb;

     ndb = CNget_NDB (conn_handle);

     if (ndb) {
          process_data (ndb->ndata, ndb->len);
          KRfree (ndb->ptr);
          KRfree (ndb);
        }
       else {
          /* No data available yet, or an error occured ! */
        }

@line 3 62 0 0 7

Returns the pointer to the next Network Data Block, or NULL if an error
occured or no Network Data Blocks are queued.

Note 1: This function is not capable of returning real error codes. Since
network errors are reported only once, and cleared by every data transfer
function (CNget_NDB too),  the @{"CIB" LINK "The `CIB' Structure"} status entry for this connection (see
@{"CNgetinfo" LINK "The `CNgetinfo' Function"}) should be checked whenever CNget_NDB is used and returns NULL.

Note 2: An exception exists to the above rule of CNget_NDB not returning
normal error codes. Under special circumstances (see @{"TCP_info" LINK "The `TCP_info' Function"} and UDPinfo
comments on DEFER mode) it can return (@{"NDB" LINK "NDB"} *)E_LOCKED, and should then be
tested by some typecast expression.  In fact it is a good idea under most
conditions to test returned pointers by  "if ((int32) p) < 0)"  to detect
illegal pointer values (that may sometimes represent error codes).  Doing
so improves safety and possibly improves compatibility with future usage.

@endnode


@pnode "NDB"
The  Network Data Block :

typedef struct ndb
{
    char        *ptr;     /* Ptr. to base of block     */
    char        *ndata;   /* Ptr. to data to deliver   */
    uint16      len;      /* Length of remaining data  */
    struct ndb  *next;    /* Next NDB in chain or NULL */
} NDB;
@endnode


@node "The `CNget_block' Function"
@symbol ar "CNget_block"
@prev "The `CNget_NDB' Function"
The `CNget_block' Function                                         STinG
@line 1 72 0 0 7


    int16  cdecl  CNget_block (int16 handle, char *buffer, int16 length);


Function :
   Fetch a received block of data from a connection.


The function description is not available yet, since this function might
see an extension of it's specification soon. Here is the specification
by Steve Adam as a kludge :

  - Fills a block starting at `buffer' with `length' bytes from `handle'.

  - If the input queue has less than `length' bytes, then no
    data will be transferred.
    Note this statement might get dropped from the specification.

  - Returns the number of bytes you requested, or an
    error code.  E_NODATA is *not* a fatal error.

@endnode


@node "The `CNgetinfo' Function"
@symbol ar "CNgetinfo"
The `CNgetinfo' Function                                           STinG
@line 1 72 0 0 7


    @{"CIB" LINK "The `CIB' Structure"} *  cdecl  CNgetinfo (int16 handle);


Function :
   Fetch information about a connection.


This function returns a pointer to a @{"CIB structure" LINK "The `CIB' Structure"}, that contains all im-
portant information on a TCP or UDP connection. The information comprises
IP addresses of both endpoints and port numbers, etc. This information is
'live' in the sense, that it gets updated by STinG automatically,  but it
is not possible to alter the connection's behaviour by writing to the @{"CIB" LINK "The `CIB' Structure"}
structure.

The @{"CIB" LINK "The `CIB' Structure"} structure must not be accessed anymore, after the associated con-
nection has been fully closed using the appropriate call.

Returns either the pointer to the @{"CIB" LINK "The `CIB' Structure"}, or NULL in case of an error.

@endnode


@node "The `CIB' Structure"
@symbol ar "CIB"
@next "The `CNgets' Function"
The `CIB' Structure                                                STinG
@line 1 72 0 0 7

The Connection Information Block structure. A pointer to this structure
is returned by @{"CNgetinfo" LINK "The `CNgetinfo' Function"}.

typedef struct cib
{
    uint16   protocol;     /* TCP or UDP or ...               */
    @{"CAB" LINK "CAB"}      address;      /* Adress information              */
    uint16   status;       /* @{"Net status" LINK "Net Status"}. 0 means normal      */
} CIB;

@endnode


@pnode "CAB"
CAB is a word with two different meanings to STinG.

'Cool Atari Browser' is the most popular web browser,
but in C programs CAB means Connection Addressing Block :

typedef  struct cab
{
    uint16   lport;      /* Local  machine port        */
    uint16   rport;      /* Remote machine port        */
    uint32   rhost;      /* Remote machine IP address  */
    uint32   lhost;      /* Local  machine IP address  */
} CAB;
@endnode


@pnode "Net Status"
The ICMP Network Status for the associated TCP / UDP connec-
tion is a 16 bit word containing the information of the last
received ICMP packet regarding the connection. The ICMP type
is encoded in the upper 8 bits, the ICMP code in the lower 8
bits. The ICMP type can be :

   3   Dest. unreachable      11   Time-To-Live exceeded
   4   Source Quench          12   Parameter problem
   5   Redirect

The meaning of the code value depends on the ICMP type.
@endnode


@node "The `CNgets' Function"
@symbol ar "CNgets"
@prev "The `CIB' Structure"
The `CNgets' Function                                              STinG
@line 1 72 0 0 7


    int16  cdecl  CNgets (int16 cn, uint8 *buffer, int16 len, uint8 delim);


Function :
   Fetch a delimited block of data from a connection.


Similar to the @{I}stdio@{i}'s  gets() call,  this function receives data until a
specified delimiter is encountered. For text streams, `delim' will be most
often '\r' or '\n'.  For the former case, for instance, all data until the
'\r' byte will be transferred to the specified buffer,  if `len' specifies
it to be long enough.  The '\r' will not be transferred,  but read, and in
the buffer the block will get terminated by a '\0' byte.  The call returns
the number of bytes read until the delimiter was found, i.e. the length of
the buffer contents without the final '\0' byte.

Note that when reading "\r\n" delimited streams,  the call will not filter
the '\n' if `delim' is '\r', and vice versa.

Obviously this function  is most suitable for stream oriented  connections
(TCP), but it works with datagram oriented protocols (UDP) too.  On these,
successive datagrams  are treated like a  stream of bytes.  Naturally this
makes sense only under rather special circumstances.

The function returns E_NORMAL in case of normal operation. E_NODATA is re-
turned if there is not enough data in the input buffer to find the delimi-
ter, or E_BIGBUF if the buffer is not large enough to hold the whole block
of data. In the latter two cases, no data is read.

Generic TCP / UDP errors returned here are E_LISTEN, E_EOF, E_CONNECTFAIL,
E_REFUSE or E_RRESET.  For network errors, the E_UNREACHABLE, E_CNTIMEOUT
and E_TTLEXCEED codes are returned.

@endnode


@node "The `CNfree_NDB' Function"
@symbol ar "CNfree_NDB"
The `CNfree_NDB' Function                                          STinG
@line 1 72 0 0 7

    void cdecl CNfree_NDB(int16 cn, @{"NDB" LINK "NDB"} *block);

Function :
    Frees an @{"NDB" LINK "NDB"} from the queue of connection cn.
    For use with @{"CNget_NDB" LINK "The `CNget_NDB' Function"} call

NB: This function only exists in STinG kernel 1.26 and later.
    For older kernels you must use "@{"KRfree" LINK "The `KRfree' Function"}(block->ptr); KRfree(block);"
    instead, and that method will work fine for newer kernels too.

@endnode


@node "The Port Manager"
The Port Manager                                                   STinG
@line 1 72 0 0 7

The Port Manager contains all those functions that are used for dealing
with STinG ports. Ports can be switched on or off, and their state may
be inquired. Another function deals with configuration.

These calls are :

    int16  cdecl  @{"on_port" LINK "The `on_port' Function"} (char *);
    void   cdecl  @{"off_port" LINK "The `off_port' Function"} (char *);
    int16  cdecl  @{"query_port" LINK "The `query_port' Function"} (char *);
    int16  cdecl  @{"cntrl_port" LINK "The `cntrl_port' Function"} (char *, uint32, int16);
@endnode


@node "The `on_port' Function"
@symbol ar "on_port"
The `on_port' Function                                             STinG
@line 1 72 0 0 7


    int16  cdecl  on_port (char *port_name);


Function :
   Switches a port into active mode and triggers initialisation.


This function activates the specified port if it is not already activat-
ed.  Upon activation, the interface is restarted  (PPP does a renegotia-
tion for instance), and the statistics counters are cleared.

`port_name' is a pointer to a string of characters, that must match the
string that is given by the `name' entry in one of the @{"PORT" LINK "The `PORT' Structure"} structures
installed into STinG.  If a matching structure is found,  it's `driver'
entry is followed to a @{"DRIVER" LINK "DRIVER"} structure, which contains a pointer to the
`set_state' code that must be called for activating a port.

Returns FALSE if the specified port does not exist, or was desactivated
and could not be activated. If the port is activated afterwards, TRUE is
returned.

@endnode


@node "The `off_port' Function"
@symbol ar "off_port"
The `off_port' Function                                            STinG
@line 1 72 0 0 7


    void   cdecl  off_port (char *port_name);


Function :
   Switches a port into inactive mode.


If the specified interface exists, and is activated, it is desactivated.
This involves a "down" action on the interface,  which depending on the
interface and the used protocol can lead to hang-up actions etc.

`port_name' is a pointer to a string of characters, that must match the
string that is given by the `name' entry in one of the @{"PORT" LINK "The `PORT' Structure"} structures
installed into STinG.  If a matching structure is found,  it's `driver'
entry is followed to a @{"DRIVER" LINK "DRIVER"} structure, which contains a pointer to the
`set_state' code that must be called for desactivating a port.

@endnode


@node "The `query_port' Function"
@symbol ar "query_port"
The `query_port' Function                                          STinG
@line 1 72 0 0 7


    int16  cdecl  query_port (char *port_name);


Function :
   Inquires if a specified port is currently active.


If the specified interface exists, this function determines if it is ac-
tivated, or desactivated. FALSE is returned if either the interface is
currently desactivated, or does not exist at all. TRUE is returned only
if the interface exists and is activated.

`port_name' is a pointer to a string of characters, that must match the
string that is given by the `name' entry in one of the @{"PORT" LINK "The `PORT' Structure"} structures
installed into STinG.  If a matching structure is found,  it's `active'
entry is returned by query_port.

@endnode


@node "The `cntrl_port' Function"
@symbol ar "cntrl_port"
@next "The Miscellaneous Manager"
The `cntrl_port' Function                                          STinG
@line 1 72 0 0 7


    int16  cdecl  cntrl_port (char *port_name, uint32 arg, int16 code);


Function :
   Inquires and sets various parameters of STinG ports.


Configuring ports is highly dependent on the driver.  The driver in turn
depends on the hardware.  This call provides a generic way to access the
driver parameters. To this end the name of the port to be dealt with must
be passed as the first parameter of this call.

A function code, to be passed as the last parameter, specifies precisely
with action is wanted to be carried out. For an exhaustive list of which
function codes are supported, see the @{"documentation" LINK "STinG Modules"} of the driver. There
is another argument `arg' that must be passed, which represents the para-
meter for the specified action.  It's meaning depends on the function to
be carried out.  For queries, it will be a pointer to some variable that
the call is wanted to fill in.

If a NULL pointer is passed for the `port_name' parameter,  the function
is not delegated to any driver. Instead the kernel checks for either one
of CTL_KERN_FIRST_PORT and CTL_KERN_NEXT_PORT.  These codes are designed
for a step by step query of a list of names of available ports that were
installed at boot time. For beginning the query, use CTL_KERN_FIRST_PORT,
then successively CTL_KERN_NEXT_PORT for getting back another port name,
until the call returns E_NODATA. `arg' must be a pointer to a @{"PNTA" LINK "PNTA"} struc-
ture,  which contains the length and the address of the buffer where the
call is meant to copy the name to. CLT_KERN_FIND_PORT can be used to get
the pointer to the @{"PORT" LINK "The `PORT' Structure"} structure of the specified port.

No driver will ever see the former three function codes.  The following
codes are always available too, and the driver chooses if it handles the
corresponding function, or not. The kernel will call the driver for that
end and will handle the request if, and only if, the driver code returns
E_FNAVAIL :

   CTL_GENERIC_SET_IP     Set and inquire the port's 32-bit IP address.
   CTL_GENERIC_GET_IP     `arg' is the IP address, or a pointer to the
                          place to fill in the IP address.

   CTL_GENERIC_SET_MASK   Set and inquire the port's subnet mask. `arg'
   CTL_GENERIC_GET_MASK   is the subnet mask, or a pointer to the place
                          to fill in the subnet mask.

   CTL_GENERIC_SET_MTU    Set and inquire the port's MTU. `arg' is the
   CTL_GENERIC_GET_MTU    MTU, or a pointer to the 16-bit place to fill
                          in the MTU.

   CTL_GENERIC_GET_MMTU   Inquire the maximum MTU or the link type res-
   CTL_GENERIC_GET_TYPE   pectively.  In both cases, `arg' is a pointer
                          to the 16-bit place to fill in the number.

   CTL_GENERIC_GET_STAT   Inquire the port statistics. `arg' is a poin-
                          ter to three 32-bit words,  which are filled
                          in with the counting of dropped packets, the
                          number of send bytes, and the number of recei-
                          ved bytes.

   CTL_GENERIC_CLR_STAT   Clear the port statistics. `arg' is not used.

Returns E_NORMAL if the action was carried out successfully.  Many other
error codes are possible. See the driver @{"documentation" LINK "STinG Modules"} for those.

@endnode


@pnode "PNTA"
The  Port Name Transfer Area.

typedef struct pnta
{
    PORT    *opaque;         /* Ignore this entry      */
    int16   name_len;        /* Length of name buffer  */
    char    *port_name;      /* Buffer address         */
} PNTA;
@endnode


@node "The Miscellaneous Manager"
@prev "The `cntrl_port' Function"
The Miscellaneous Manager                                          STinG
@line 1 72 0 0 7

The Miscellaneous Manager contains all those functions that do not fit
easily into other managers. Thus this collection of calls is a little
arbitrary.

These calls are :

    char *  cdecl  @{"get_err_text" LINK "The `get_err_text' Function"} (int16);
    char *  cdecl  @{"getvstr" LINK "The `getvstr' Function"} (char *);
    int16   cdecl  @{"setvstr" LINK "The `setvstr' Function"} (char *, char *);
    int16   cdecl  @{"set_flag" LINK "The `set_flag' Function"} (int16);
    void    cdecl  @{"clear_flag" LINK "The `clear_flag' Function"} (int16);
    int16   cdecl  @{"resolve" LINK "The `resolve' Function"} (char *, char **, uint32 *, int16);
@endnode


@node "The `get_err_text' Function"
@symbol ar "get_err_text"
The `get_err_text' Function                                        STinG
@line 1 72 0 0 7


    char *  cdecl  get_err_text (int16 error_code);


Function :
   Returns error description for a given error number.


Many functions of the STinG @{"API" LINK "API"} return negative @{"error codes" LINK "STinG Error Codes"} after a pro-
blem happened during execution. It is a tedious task to provide a corres-
ponding error text in a client for every error that might happen. STinG
thus provides a text description for any error, if the client passes the
error code to this call. A pointer to a text line that is ready for out-
put to a status or error line will be returned. The lines are a maximum
of 40 characters long.

@endnode


@node "STinG Error Codes"
STinG Error Codes                                                  STinG
@line 1 72 0 0 7

The following error codes may be returned by STinG @{"API" LINK "API"} functions.

The text in quotes behind the symbolic error code is the text returned
by the @{"get_err_text" LINK "The `get_err_text' Function"} function.

    0    E_NORMAL           "No error."
   -1    E_OBUFFULL         "Can't send, output buffer is full."
   -2    E_NODATA           "No data available."
   -3    E_EOF              "EOF received from a remote host."
   -4    E_RRESET           "RESET received from a remote host."
   -5    E_UA               "Unacceptable packet, sending RESET."
   -6    E_NOMEM            "No more memory available."
   -7    E_REFUSE           "Connection refused by remote host."
   -8    E_BADSYN           "TCP received SYN in window."
   -9    E_BADHANDLE        "Bad connection handle used."
  -10    E_LISTEN           "The connection is in LISTEN state."
  -11    E_NOCCB            "No free CCBs available."
  -12    E_NOCONNECTION     "A packet matches no connection."
  -13    E_CONNECTFAIL      "Failure to connect to remote port."
  -14    E_BADCLOSE         "Invalid TCP_close() requested."
  -15    E_USERTIMEOUT      "User timeout expired."
  -16    E_CNTIMEOUT        "Connection timed out."
  -17    E_CANTRESOLVE      "DNS query, can't resolve hostname."
  -18    E_BADDNAME         "Bad format in domain name / dotted quad."
  -19    E_LOSTCARRIER      "Modem lost carrier signal."
  -20    E_NOHOSTNAME       "Hostname does not exist."
  -21    E_DNSWORKLIMIT     "Resolver reached work limit."
  -22    E_NONAMESERVER     "No nameserver found for query."
  -23    E_DNSBADFORMAT     "DNS query, bad format received."
  -24    E_UNREACHABLE      "Destination host is unreachable."
  -25    E_DNSNOADDR        "No address records found for hostname."
  -26    E_NOROUTINE        "Routine is unavailable."
  -27    E_LOCKED           "Locked by another application."
  -28    E_FRAGMENT         "Error during fragmentation."
  -29    E_TTLEXCEED        "Time To Live exceeded, discarded."
  -30    E_PARAMETER        "Problem with a parameter."
  -31    E_BIGBUF           "Input buffer is too small for data."
  -32    E_FNAVAIL          "Function is not available."

@endnode


@node "The `getvstr' Function"
@symbol ar "getvstr"
The `getvstr' Function                                             STinG
@line 1 72 0 0 7


    char *  cdecl  getvstr (char *specifier);


Function :
   Inquires about a configuration string.


This function is used to read the configuration strings from the file
DEFAULT.CFG. For instance if the line

     THREADING = 200

exists in the DEFAULT.CFG, then the call

     getvstr ("THREADING");

returns a pointer to the string "200". The lookup is not case sensitive,
so that inquiring "threading" leads to the same result. The pointer is
to the first non blank character after the `=' character.

If the specified variable does not exist, a pointer to "0" is returned,
the same result is returned if no non blank character follows after the
`=' character. If even the `=' does not exit, the mere presence of the
variable is indicated by returning a pointer to "1".

See also @{"setvstr" LINK "The `setvstr' Function"}()

@endnode


@node "The `setvstr' Function"
@symbol ar "setvstr"
The `setvstr' Function                                             STinG
@line 1 72 0 0 7


    int16  cdecl  setvstr (char *specifier, char *value);


Function :
   Sets configuration strings.


This function can be used to create or modify a specified configuration
string. A new variable, named by the text the `specifier' points to, is
created if it did not exist. The new value is the text `value' points to.
For example, to achieve the same as if the line

     DIALER = 10.11.12.13

were present in DEFAULT.CFG at boot time, simply call

     setvstr ("DIALER", "10.11.12.13");

and later calls to @{"getvstr" LINK "The `getvstr' Function"} with the `specifier' "DIALER" will return a
pointer to the text "10.11.12.13".

@endnode


@node "The `set_flag' Function"
@symbol ar "set_flag"
The `set_flag' Function                                            STinG
@line 1 72 0 0 7


    int16  cdecl  set_flag (int16 flag_number);


Function :
   Requests a semaphore.


This function uses the noninteruptable MC680X0 instruction "TAS" to set a
semaphore which is specified by the number passed to the call. If it has
been called before with the same semaphore number (i.e. lock denied), the
function returns TRUE. Otherwise the caller got the lock, and FALSE will
be returned.

The lock numbers will be assigned each for a special purpose. Anyone who
wants a new lock to be defined, must coordinate with us !

See also @{"clear_flag" LINK "The `clear_flag' Function"}()

@endnode


@node "The `clear_flag' Function"
@symbol ar "clear_flag"
The `clear_flag' Function                                          STinG
@line 1 72 0 0 7


    void  cdecl  clear_flag (int16 flag_number);


Function :
   Releases a semaphore.


This function releases a semaphore regardless of it's current status. It
should be called after the lock has been succesfully requested via the
@{"set_flag" LINK "The `set_flag' Function"} call, and access is finished. The calls returns nothing.

@endnode


@node "The `resolve' Function"
@symbol ar "resolve"
The `resolve' Function                                             STinG
@line 1 72 0 0 7


    int16  cdecl  resolve (char *inp, char **real, uint32 *lst, int16 len);


Function :
   Carries out DNS queries.


This function does a DNS query to find out the dotted quad IP address for
a given domain name, and vice versa. The parameter `inp' is a pointer to
the input string, which is either a dotted quad IP address, or a domain
name. The `real' is either NULL, or a pointer to a character pointer that
will be filled in with a pointer to the found domain name. If `inp' points
to a domain name, it is checked if this is an alias, and the real domain
name is returned via `real'. All found dotted quad IP addresses are filled
into the address array pointed to by `lst', the maximum length of the list
is specified by `len'.

If `real' is not NULL, a pointer is filled into `*real'. When the string
it points to has been evaluated, it's space must be freed by using the
@{"KRfree" LINK "The `KRfree' Function"} call :

     KRfree(*real);

Returns the number of dotted quad IP addresses filled in, or an error.

Note that only a dummy function is available if RESOLVE.STX is not loaded.
This dummy always returns E_CANTRESOLVE.

@endnode


@node "The Dummy Manager"
The Dummy Manager                                                  STinG
@line 1 72 0 0 7

The Dummy Manager contains all the functions that are obsolete in STinG,
but were necessary in old STiK versions, plus some new functions of STiK2
that have no real motivation in STinG, which has other methods available.
They are defined in STinG for compatibility reasons only, to avoid bombs
when a client program uses them.  In STinG they have no real effects.

The old STiK calls are :
    int16  cdecl  @{"carrier_detect" LINK "The `carrier_detect' Function"} (void);
    void   cdecl  @{"housekeep" LINK "The `housekeep' Function"} (void);
    void   cdecl  @{"ser_disable" LINK "The `ser_disable' Function"} (void);
    void   cdecl  @{"ser_enable" LINK "The `ser_enable' Function"} (void);

Those four old STiK calls will never return any error codes.

The new STiK2 calls are :
    int16  cdecl  @{"RAW_open" LINK "The `RAW_open' Function"} (uint32);
    int16  cdecl  @{"RAW_close" LINK "The `RAW_close' Function"} (int16);
    int16  cdecl  @{"RAW_out" LINK "The `RAW_out' Function"} (int16, void *, int16, uint32);
    int16  cdecl  @{"CN_setopt" LINK "The `CN_setopt' Function"} (int16, int16, const void *, int16);
    int16  cdecl  @{"CN_getopt" LINK "The `CN_getopt' Function"} (int16, int16, void *, int16 *);

These five STiK2 calls will return E_NOROUTINE, as they do not perform
any of the work that they would do under STiK2.  (This may change later)

@endnode


@node "The `carrier_detect' Function"
@symbol ar "carrier_detect"
The `carrier_detect' Function                                      STinG
@line 1 72 0 0 7


    int16  cdecl  carrier_detect (void);


Function :
   Does nothing.


This function is only required because some old clients written for STiK
might use it. In STinG it exists only for compatibility. In those good
ole days this function was used to look up the state of the only port's
DCD line.

Returns always +1, meaning carrier is always on.

@endnode


@node "The `housekeep' Function"
@symbol ar "housekeep"
The `housekeep' Function                                           STinG
@line 1 72 0 0 7


    void  cdecl  housekeep (void);


Function :
   Does nothing.


This function is only required because some old clients written for STiK
might use it. In STinG it exists only for compatibility. STiK only opera-
ted from an application and there was no interupt driving mechanism. In
order to not loose any datagrams this function had to be called from time
to time.

@endnode


@node "The `ser_disable' Function"
@symbol ar "ser_disable"
The `ser_disable' Function                                         STinG
@line 1 72 0 0 7


    void  cdecl  ser_disable (void);


Function :
   Does nothing.


This function is only required because some old clients written for STiK
might use it. In STinG it exists only for compatibility. It was intented
to disable the serial port for short periods of time if parallel DMA was
not available. After the DMA operation the port had to be activated again
using @{"ser_enable" LINK "The `ser_enable' Function"}.

@endnode


@node "The `ser_enable' Function"
@symbol ar "ser_enable"
The `ser_enable' Function                                          STinG
@line 1 72 0 0 7


    void  cdecl  ser_enable (void);


Function :
   Does nothing.


This function is only required because some old clients written for STiK
might use it. In STinG it exists only for compatibility. In STiK this call
was used to enable the port again after is has been desactivated via the
@{"ser_disable" LINK "The `ser_disable' Function"} call.

@endnode


@node "The `RAW_open' Function"
@symbol ar "RAW_open"
The `RAW_open' function                                            STinG
@line 1 72 0 0 7

    int16     cdecl RAW_open(uint32 rhost)

Under STiK2 this will:
  - Open a RAW connection with rhost on port 0.
       The port is not really integral for the type of functions
          where the RAW protocol is used.
  - Returns connection handle or error code.
  - RAW is used primarily by utilities such as Ping or Traceroute.

Under STinG it will simply return E_NOROUTINE (this may change later),
as STinG has other means for support of ICMP and other IP protocols.

@endnode


@node "The `RAW_close' Function"
@symbol ar "RAW_close"
The `RAW_close' function                                           STinG
@line 1 72 0 0 7

    int16     cdecl RAW_close(int16 cn)

Under STiK2 this will:
  - Close the RAW connection cn.
  - Frees the connection handle and any blocks pending in the
    input queue, returns immediately.

Under STinG it will simply return E_NOROUTINE (this may change later),
as STinG has other means for support of ICMP and other IP protocols.

@endnode


@node "The `RAW_out' Function"
@symbol ar "RAW_out"
The `RAW_out' function                                             STinG
@line 1 72 0 0 7

    int16 cdecl RAW_out(int16 cn, void *data, int16 dlen, uint32 dest)

Under STiK2 this will:
  - Send dlen bytes from data to the connection cn.
  - Return E_NORMAL or an error code.

  - @{"CN_setopt" LINK "The `CN_setopt' Function"} modifies how this command is used

        If the client app sets the options on this Connection,
  to  IP_HDRINCL, then STiK assumes that the client has already
  completely constructed a packet for transmission and will simply
  pass it onto the router for transmision.

        If the IP_HDRINCL option is off the STiK will finish making
  the packet for the client.  Using the default TTL and TOS for the
  packet and will give it the Protocol of RAW.

  - Note this second option needs a complete packet to be set up and
     pointed to by data and the full length passed in dlen.  You are
     responsible for completely setting up the packet just as the
     stack would.  Failure to do so could lead to failure of the
     packet at the remote end.

Under STinG it will simply return E_NOROUTINE (this may change later),
as STinG has other means for support of ICMP and other IP protocols.

@endnode


@node "The `CN_setopt' Function"
@symbol ar "CN_setopt"
The `CN_setopt' function                                           STinG
@line 1 72 0 0 7

    int16 cdecl
    CN_setopt(int16 cn, int16 opt_id, const void *optval, int16 optlen);

Under STinG it will simply return E_NOROUTINE (this may change later),
but under STiK2 it is defined as follows:

   - opt_id chooses the option to set:
    IP_HDRINCL
    IP_TOS
    IP_TTL

   - Sets the value of a socket option for connection cn.
   - Client passes the connection in cn, the option in opt_id,
   - and an appropriate pointer in optval.  The optlen argument,
   - length of the option value, is not necessary. It is there so
   - that there is one less line to edit when porting BSD code.
   - In the case of IP_HDRINCL it is not necessary to pass optval.

   - Returns:
      - E_NORMAL if it could process the option
      - E_PARAMETER if the option is currently unsupported
      - E_BADHANDLE if the connection doesn't exist
@endnode


@node "The `CN_getopt' Function"
@symbol ar "CN_getopt"
The `CN_getopt' function                                           STinG
@line 1 72 0 0 7

    int16 cdecl
    CN_getopt(int16 cn, int16 optname, void *optval, int16 *optlen);

Under STinG it will simply return E_NOROUTINE (this may change later),
but under STiK2 it is defined as follows:

   - opt_id chooses the option to get:
    IP_HDRINCL
    IP_TOS
    IP_TTL

   - Client passes the connection in cn, the option in opt_id,
   - and an appropriate pointer in optval and optlen. The latter,
   - length of the option value, is not necessary (so use NULL).

   - Returns:
      - E_NORMAL if it could process the option
      - E_PARAMETER if the option is currently unsupported
      - E_BADHANDLE if the connection doesn't exist

@endnode


@node "The System Manager"
The System Manager                                                 STinG
@line 1 72 0 0 7

The System Manager contains all the functions that are designed for mis-
cellaneous use by modules and access the IP core. Two functions manage a
datagram's time-to-live, another one calls some code with all interrupts
disabled for safety, and calls for setting and inquiring internal varia-
bles are provided.

These calls are :

    void   cdecl  @{"set_dgram_ttl" LINK "The `set_dgram_ttl' Function"} (IP_DGRAM *);
    int16  cdecl  @{"check_dgram_ttl" LINK "The `check_dgram_ttl' Function"} (IP_DGRAM *);
    int32  cdecl  @{"set_sysvars" LINK "The `set_sysvars' Function"} (int16, int16);
    void   cdecl  @{"query_chains" LINK "The `query_chains' Function"} (PORT **, DRIVER **, LAYER **);
    int16  cdecl  @{"protect_exec" LINK "The `protect_exec' Function"} (void *, int32 cdecl (*) ());
@endnode


@node "The `set_dgram_ttl' Function"
@symbol ar "set_dgram_ttl"
The `set_dgram_ttl' Function                                       STinG
@line 1 72 0 0 7


    void  cdecl  set_dgram_ttl (IP_DGRAM *datagram);


Function :
   Enables time-to-live checking for a datagram.


This call reads the IP header ttl field, and sets up an internal timeout
variable accordingly. The function must be called by a port driver module
whenever it receives a complete IP datagram, in order to enable checking
of the time-to-live timeout for the specified datagram by the kernel.

@endnode


@node "The `check_dgram_ttl' Function"
@symbol ar "check_dgram_ttl"
The `check_dgram_ttl' Function                                     STinG
@line 1 72 0 0 7


    int16  cdecl  check_dgram_ttl (IP_DGRAM *datagram);


Function :
   Checks a datagram for time-to-live expired, and discards if appropriate.


The function checks the remaining time to live for the specified datagram.
It should be called by port drivers just before the datagram gets send, in
order to avoid the cost of sending datagrams that will be discarded at the
other end anyway. If the time to live is okay then the function will return
without having changed anything. If the time to live has expired the data-
gram will be discarded, and an ICMP-ttl-exceeded reply will be send if the
datagram was no ICMP packet itself. In the latter case the `datagram' poin-
ter must be considered invalid.

Returns either E_NORMAL or E_TTLEXCEED.

@endnode


@node "The `set_sysvars' Function"
@symbol ar "set_sysvars"
The `set_sysvars' Function                                         STinG
@line 1 72 0 0 7


    int32  cdecl  set_sysvars (int16 new_active, int16 new_fraction);


Function :
   Inquires and sets the STinG active flag and calling frequency.


The function sets `new_active' as the new active flag for STinG, if not
-1, and sets `new_fraction' as the new call delay, if not -1. STinG is
active if the active flag is set TRUE. Then with a specified frequency
the STinG core gets called, and IP datagrams can be send, received and
distributed. The time between successive calls of the core is specified
by the `new_fraction' parameter in 5 ms units. The intial value is 10,
thus the core is called each 50 ms. Usage of this function is restricted
to configuration tools, like ConfSTinG and STING.CPX.

The function returns the settings that were active before the call was
done. The upper word of the return value contains the former active flag,
while the lower word contains the former setting of the call delay.

@endnode


@node "The `query_chains' Function"
@symbol ar "query_chains"
The `query_chains' Function                                        STinG
@line 1 72 0 0 7


    void  cdecl  query_chains (PORT **port, DRIVER **drv, LAYER **layer);


Function :
   Get addresses of module chains.


Returns pointers to the first elements of the chains of @{"PORT" LINK "The `PORT' Structure"}, @{"DRIVER" LINK "DRIVER"}, and
@{"LAYER" LINK "LAYER"} structures. Each of the structures contain a link that points to the
next element. Pointers to variables are passed with the call. The function
fills in the appropriate addresses. For addresses that are not needed a
NULL pointer may be passed.

@endnode


@node "The `PORT' Structure"
@symbol ar "PORT"
@next "The `protect_exec' Function"
The `PORT' Structure                                               STinG
@line 1 72 0 0 7

The port structure. One of these is provided by a hardware driver for each
port the driver handles.

typedef struct port_desc
{
    char      *name;            /* Name of port                          */
    int16     type;             /* Type of port                          */
    int16     active;           /* Flag for port active or not           */
    uint32    flags;            /* Type dependent operational flags      */
    uint32    ip_addr;          /* IP address of this network adapter    */
    uint32    sub_mask;         /* Subnet mask of attached network       */
    int16     mtu;              /* Maximum packet size to go through     */
    int16     max_mtu;          /* Maximum allowed value for mtu         */
    int32     stat_sd_data;     /* Statistics of sent data               */
    @{"IP_DGRAM" LINK "IP_DGRAM"}  *send;            /* Link to first entry in send queue     */
    int32     stat_rcv_data;    /* Statistics of received data           */
    @{"IP_DGRAM" LINK "IP_DGRAM"}  *receive;         /* Link to first entry in receive queue  */
    int16     stat_dropped;     /* Statistics of dropped datagrams       */
    struct drv_desc   *driver;  /* Driver program to handle this port    */
    struct port_desc  *next;    /* Next port in port chain               */
} PORT;

@endnode


@pnode "DRIVER"
typedef struct drv_desc
{
    int16  cdecl  (* set_state) (PORT *, int16);  /* Init */
    int16  cdecl  (* cntrl) (PORT *, uint32, int16);
    void   cdecl  (* send) (PORT *);         /* Send      */
    void   cdecl  (* receive) (PORT *);      /* Receive   */
    char             *name;     /* Name of driver         */
    char             *version;  /* Version as "xx.yy"     */
    uint16           date;      /* Compile date           */
    char             *author;   /* Name of programmer     */
    struct drv_desc  *next;     /* Next driver in chain   */
    BASPAG           *basepage; /* Basepage of module     */
} DRIVER;
@endnode


@pnode "LAYER"
typedef struct lay_desc
{
    char             *name;        /* Name of layer       */
    char             *version;     /* Version as xx.yy    */
    uint32           flags;        /* Private data        */
    uint16           date;         /* Compile date        */
    char             *author;      /* Name of programmer  */
    int16            stat_dropped; /* Statistics          */
    struct lay_desc  *next;        /* Next layer in chain */
    BASPAG           *basepage;    /* Basepage of module  */
} LAYER;
@endnode


@node "The `protect_exec' Function"
@symbol ar "protect_exec"
@prev "The `PORT' Structure"
The `protect_exec' Function                                        STinG
@line 1 72 0 0 7


    int32  cdecl  protect_exec (void *para, int32 cdecl (* code) (void *));


Function :
   Calls a subroutine in protected mode with parameter passing.


Often some code must never be interupted, not even by interrupts. This
is for timing critical code, or for code manipulating data structures
that are accessed from an interrupt. This function provides the means to
`protect' this code against interuption. The code must be an RTS termi-
nated subroutine that expects a pointer parameter on the stack, and that
returns a value in the CPU register D0 (Standard C binding). A pointer
to the subroutine is passed in `code', while the pointer parameter to be
passed must be provided in `para'.

Returns the return value of the called subroutine.

@endnode


@node "The IP Manager"
The IP Manager                                                     STinG
@line 1 72 0 0 7

The @{"IP" LINK "Internet Protocol (IP)"} Manager contains all those calls that are required by high level
protocol modules to do the low level network traffic. It might be urgent
traffic, hence a callback scheme can be employed by programmers choice.
Functions for sending, receiving and discarding datagrams are provided.

These calls are :

    int16      cdecl  @{"IP_send" LINK "The `IP_send' Function"} (uint32, uint32, uint8, uint16, uint8,
                               uint8, uint16, void *, uint16, void *,
                               uint16);
    IP_DGRAM * cdecl  @{"IP_fetch" LINK "The `IP_fetch' Function"} (int16);
    int16      cdecl  @{"IP_handler" LINK "The `IP_handler' Function"} (int16,
                               int16 cdecl (*) (IP_DGRAM *), int16);
    void       cdecl  @{"IP_discard" LINK "The `IP_discard' Function"} (IP_DGRAM *, int16);
@endnode


@node "The `IP_send' Function"
@symbol ar "IP_send"
@next "The `IP_HDR' Structure"
The `IP_send' Function                                             STinG
@line 1 72 0 0 7


    int16  cdecl  IP_send (uint32 src_host, uint32 dest_host, uint8 tos,
                           uint16 dont_frag, uint8 ttl, uint8 protocol,
                           uint16 ident, void *data, uint16 data_length,
                           void *options, uint16 options_length);


Function :
   Sends off IP datagrams.


This function sends an @{"IP datagram" LINK "IP_DGRAM"} from host `src_host' (that's us) to
the host `dest_host'. `src_host' may be zero, in that case the function
determines the appropriate IP address. `tos' is the @{"IP type of service" LINK "IP Type Of Service"},
`dont_frag' is a flag specifying whether to allow fragmentation (TRUE :
don't allow). `ttl' is the datagram's time-to-live in seconds, `protocol'
is either P_TCP, P_UDP or P_ICMP. `ident' is a unique identification
number, `data' is a pointer to the data to be transferred, `data_length'
is the data's length in bytes. `options' is a pointer to the IP options,
`options_length' is their length in bytes. Both `data' and `options' are
pointers that either contain NULL, or point to blocks that must have been
allocated via @{"KRmalloc" LINK "The `KRmalloc' Function"}. The call inserts all these parameters into the
@{"IP header" LINK "The `IP_HDR' Structure"}, and links the resulting datagram into the send queue.

If the call has been successful (i.e. E_NORMAL was returned) then access
to the data or the options is not allowed anymore, as if

     @{"KRfree" LINK "The `KRfree' Function"} (data);   @{"KRfree" LINK "The `KRfree' Function"} (options);

had been executed by IP_send. Thus these pointers have to be considered
invalid in that case.

Returns either E_NORMAL or E_NOMEM or E_UNREACHABLE.

@endnode


@pnode "IP_DGRAM"
typedef struct ip_packet
{
    IP_HDR    hdr;             /* Header of IP packet     */
    void      *options;        /* Options data block      */
    int16     opt_length;      /* Length of options       */
    void      *pkt_data;       /* IP packet data block    */
    int16     pkt_length;      /* Length of IP packet     */
    uint32    timeout;         /* Timeout of packet life  */
    uint32    ip_gateway;      /* Gateway for forwarding  */
    struct port_desc  *recvd;  /* Receiving port          */
    struct ip_packet  *next;   /* Next IP packet in queue */
} IP_DGRAM;
@endnode


@node "The `IP_HDR' Structure"
@symbol ar "IP_HDR"
@prev "The `IP_send' Function"
The `IP_HDR' Structure                                             STinG
@line 1 72 0 0 7

The IP header structure. This structure is a part of the internal IP
packet @{"representation" LINK "IP_DGRAM"}.

typedef struct ip_header
{
    unsigned  version   : 4;    /* IP Version                            */
    unsigned  hd_len    : 4;    /* Internet Header Length                */
    unsigned  tos       : 8;    /* Type of Service                       */
    uint16    length;           /* Total of all header, options and data */
    uint16    ident;            /* Identification for fragmentation      */
    unsigned  reserved  : 1;    /* Reserved : Must be zero               */
    unsigned  dont_frg  : 1;    /* Don't fragment flag                   */
    unsigned  more_frg  : 1;    /* More fragments flag                   */
    unsigned  frag_ofst : 13;   /* Fragment offset                       */
    uint8     ttl;              /* Time to live                          */
    uint8     protocol;         /* Protocol                              */
    uint16    hdr_chksum;       /* Header checksum                       */
    uint32    ip_src;           /* Source IP address                     */
    uint32    ip_dest;          /* Destination IP address                */
} IP_HDR;

@endnode


@node "The `IP_fetch' Function"
@symbol ar "IP_fetch"
The `IP_fetch' Function                                            STinG
@line 1 72 0 0 7


    IP_DGRAM *  cdecl  IP_fetch (int16 protocol);


Function :
   Fetches an IP datagram from the receive queue.


The function fetches an IP datagram from the queue associated with the
protocol specified. It returns NULL if there is none, otherwise a pointer
to the datagram is returned. The datagram is now under complete control
of the calling code. Particularly it must be discarded via the @{"IP_discard" LINK "The `IP_discard' Function"}
call after use.

@endnode


@node "The `IP_handler' Function"
@symbol ar "IP_handler"
The `IP_handler' Function                                          STinG
@line 1 72 0 0 7


    int16  cdecl  IP_handler (int16 protocol,
                              int16 cdecl (* handler) (IP_DGRAM *),
                              int16 install_code);


Function :
   Install and deinstall handlers for high level protocols.


A handler function for dealing immediately with incoming datagrams for
a specific protocol can be installed using this call. The handler will
be called for each datagram that comes in and that is bound for that
protocol. The handler shall return with TRUE, if the datagram has been
completely processed, then the datagram will be discarded by the kernel
afterwards. If the handler returns FALSE the datagram will be linked
into the receive queue for that protocol, and can be fetched later via
@{"IP_fetch" LINK "The `IP_fetch' Function"}.

Do not try to install a handler for ICMP using this function, use the
@{"ICMP_handler" LINK "The `ICMP_handler' Function"} call instead.

The installed function is called from the main interupt, thus may use
only a very limited amount of CPU time. Hence waiting for any event is
not allowed. The call is done asynchronously in Supervisor mode, thus
care must be execised with using any operating system call within the
handler function.

The `install code' can be

   HNDLR_SET :
        Install a new handler. The call returns TRUE if there was no
        handler installed before, and the new handler has been put in
        place.

   HNDLR_FORCE :
        Install a new handler, not caring whether there was a handler
        already installed or not. Returns TRUE. Apply with care !

   HNDLR_REMOVE :
        Declare a handler, that has been installed earlier, as invalid.
        This handler won't be called anymore. This must be done when a
        program that installed a handler, terminates.

   HNDLR_QUERY :
        Inquire whether there is a handler installed, without changing
        it. Returns TRUE if there is one already, and FALSE, if not.

@endnode


@node "The `IP_discard' Function"
@symbol ar "IP_discard"
The `IP_discard' Function                                          STinG
@line 1 72 0 0 7


    void  cdecl  IP_discard (IP_DGRAM *datagram, int16 all_flag);


Function :
   Discards an IP datagram.


There are several occasions when IP datagrams must be discarded. This is
mainly for releasing the memory the datagram occupies. A pointer to the
datagram must be passed. After calling this function the address pointed
to by the pointer `datagram' is not valid anymore.

High level protocols often need to discard just the IP overhead, but need
to keep the data, in order to avoid recopying it to some other place. For
this purpose the extra parameter `all_flag' can be set to FALSE. In that
case the memory occupied by both IP header and options is freed, but the
memory block the `datagram->pkt_data' points too is not released, but in
fact stays allocated and is owned by the caller.

@endnode


@node "The Protocol Manager"
The Protocol Manager                                               STinG
@line 1 72 0 0 7

The Protocol Manager contains all those functions that are specifically
used by modules implementing high lebel protocols. There are functions
for announcing the presence, for inquiring about special parameters, and
for managing connection handles.

These calls are :

    int16   cdecl  @{"PRTCL_announce" LINK "The `PRTCL_announce' Function"} (int16);
    int16   cdecl  @{"PRTCL_get_parameters" LINK "The `PRTCL_get_parameters' Function"} (uint32, uint32 *, int16 *, uint16 *);
    int16   cdecl  @{"PRTCL_request" LINK "The `PRTCL_request' Function"} (void *, CN_FUNCS *);
    void    cdecl  @{"PRTCL_release" LINK "The `PRTCL_release' Function"} (int16);
    void *  cdecl  @{"PRTCL_lookup" LINK "The `PRTCL_lookup' Function"} (int16, CN_FUNCS *);
@endnode


@node "The `PRTCL_announce' Function"
@symbol ar "PRTCL_announce"
The `PRTCL_announce' Function                                      STinG
@line 1 72 0 0 7


    int16  cdecl  PRTCL_announce (int16 protocol);


Function :
   Announces that a high level protocol is active.


Modules implementing high level protocols, like TCP or UDP, must call this
function in order to receive any datagrams. If the function is not called,
the IP core sends back an `ICMP destination unreachable' message upon re-
ception of any datagram that is bound for that protocol, and discards the
datagram.

Returns a flag indicating whether PRTCL_announce has been called with that
protocol number before (TRUE) or if this is the first call (FALSE). If the
returned value is TRUE, the module should refrain of installing itself.

@endnode


@node "The `PRTCL_get_parameters' Function"
@symbol ar "PRTCL_get_parameters"
The `PRTCL_get_parameters' Function                                STinG
@line 1 72 0 0 7


    int16  cdecl  PRTCL_get_parameters (uint32 rem_IP, uint32 *lcl_IP,
                                        int16 *ttl, uint16 *mtu);


Function :
   Fetch high level protocol parameters from the STinG core.


High level protocols usually include the source (local) IP address in
their packets. A time-to-live (ttl) must be specified too when sending
the packet off via the @{"IP_send" LINK "The `IP_send' Function"} call. Occasionly it is useful to adjust
packet size to the maximum value in order to avoid unnecessary fragmen-
tation. To provide some means to inquire about these parameters this
call has been implemented. The destination host's IP address is passed
via the first parameter. The `lcl_IP', `ttl' and `mtu' parameters are
pointers to appropriate variables that are filled in by this function.
For pointers to unused parameters NULL can be used.

Returns either E_NORMAL or E_UNREACHABLE.

@endnode


@node "The `PRTCL_request' Function"
@symbol ar "PRTCL_request"
The `PRTCL_request' Function                                       STinG
@line 1 72 0 0 7


    int16  cdecl  PRTCL_request (void *connect, CN_FUNCS *functions);


Function :
   Fetches a new connection handle from the handle pool.


High level protocols share a common set of receive data functions. Thus
their connection handles must be kept unique. This is achieved by the
corresponding module using the PRTCL_request, the @{"PRTCL_release" LINK "The `PRTCL_release' Function"} and the
@{"PRTCL_lookup" LINK "The `PRTCL_lookup' Function"} function for managing the handle pool.

PRTCL_request is used to get a new connection handle out of a pool of
32765 handles. By passing the parameter `connect' a pointer to a struc-
ture with connection related data is associated with the handle, thus
the module does not need to keep track of handles and associated data.
The data structure is completely internal to the module, it may contain
any data. The `functions' parameter is a pointer to a @{"CN_FUNCS" LINK "CN_FUNCS"} struc-
ture which contains a set of pointers to receive functions, which are
called when any client calls an @{"API" LINK "API"} function from the @{"connection manager" LINK "The Connection Manager"}
with a handle that belongs to the protocol supported by the module.

A value of NULL is acceptable for `connect', but `functions' must have
a meaning. It is suggested to have a @{"CN_FUNCS" LINK "CN_FUNCS"} structure in the code with
the appropriate function pointers, and pass the address of that struc-
ture whenever PRTCL_request is to be used.

Any function of the module that is passed a connection handle, can use
the @{"PRTCL_lookup" LINK "The `PRTCL_lookup' Function"} function to retrieve the pointer to the associated data.
Any function from the @{"CN_FUNCS" LINK "CN_FUNCS"} structure is called directly with this
pointer as the first argument. After use, when closing the connection,
the handle must be returned using the @{"PRTCL_release" LINK "The `PRTCL_release' Function"} call.

PRTCL_request returns a new handle, or -1 if an error occurred.

@endnode


@node "The `PRTCL_release' Function"
@symbol ar "PRTCL_release"
The `PRTCL_release' Function                                       STinG
@line 1 72 0 0 7


    void  cdecl  PRTCL_release (int16 handle);


Function :
   Returns a used connection handle to the handle pool.


High level protocols share a common set of receive data functions. Thus
their connection handles must be kept unique. This is achieved by the
corresponding module using the @{"PRTCL_request" LINK "The `PRTCL_request' Function"}, the PRTCL_release and the
@{"PRTCL_lookup" LINK "The `PRTCL_lookup' Function"} function for managing the handle pool.

Every handle that has been fetched via the @{"PRTCL_request" LINK "The `PRTCL_request' Function"} call must be
returned eventually to avoid handle pool exhaustion. Thus any module
that implements a protocol that uses the @{"connection manager" LINK "The Connection Manager"} must call
PRTCL_release from it's close function, and pass the handle it got from
calling @{"PRTCL_request" LINK "The `PRTCL_request' Function"}.

@endnode


@node "The `PRTCL_lookup' Function"
@symbol ar "PRTCL_lookup"
@next "The Timing Manager"
The `PRTCL_lookup' Function                                        STinG
@line 1 72 0 0 7


    void *  cdecl  PRTCL_lookup (int16 handle, CN_FUNCS *functions);


Function :
   Looks up the data for a given connection handle.


High level protocols share a common set of receive data functions. Thus
their connection handles must be kept unique. This is achieved by the
corresponding module using the @{"PRTCL_request" LINK "The `PRTCL_request' Function"}, the @{"PRTCL_release" LINK "The `PRTCL_release' Function"} and the
PRTCL_lookup function for managing the handle pool.

Any function declared in the @{"CN_FUNCS" LINK "CN_FUNCS"} structure gets the address of the
connection related data passed directly as the first argument. A module
wishing to implement other @{"API" LINK "API"} calls (for instance a `send' call) that
are independent from the @{"connection manager" LINK "The Connection Manager"}, must do a separate lookup
to retrieve this address. To save the module the effort of keeping track
of handle - connection data relations, the address can be looked up using
this call. The handle is passed as the first parameter, the address of
the @{"CN_FUNCS" LINK "CN_FUNCS"} structure for the connection must be passed too to ensure
only the right module accesses the data.

For speed a quick hash retrieval scheme is used by PRTCL_lookup.

PRTCL_lookup returns the address of connection related data, or NULL if
the handle does not exist or belongs to a different module.

@endnode


@pnode "CN_FUNCS"
typedef struct cn_funcs
{
    int16  cdecl  (* CNkick) (void *cn);
    int16  cdecl  (* CNbyte_count) (void *cn);
    int16  cdecl  (* CNget_char) (void *cn);
    NDB *  cdecl  (* CNget_NDB) (void *cn);
    int16  cdecl  (* CNget_block) (void *cn, void *buf,
                                   int16 len);
    CIB *  cdecl  (* CNgetinfo) (void *cn);
    int16  cdecl  (* CNgets) (void *cn, char *buf,
                              int16 len, char delim);
} CN_FUNCS;
@endnode


@node "The Timing Manager"
@prev "The `PRTCL_lookup' Function"
The Timing Manager                                                 STinG
@line 1 72 0 0 7

The Timing Manager provides functionality for regularly called functions
and for timing purposes, i.e. timeout counters etc. For timing, functions
for inquiring about time, and elapsed time since a given moment, are pro-
vided.

These calls are :

    int16  cdecl  @{"TIMER_call" LINK "The `TIMER_call' Function"} (void cdecl (*) (void), int16);
    int32  cdecl  @{"TIMER_now" LINK "The `TIMER_now' Function"} (void);
    int32  cdecl  @{"TIMER_elapsed" LINK "The `TIMER_elapsed' Function"} (int32);
@endnode


@node "The `TIMER_call' Function"
@symbol ar "TIMER_call"
The `TIMER_call' Function                                          STinG
@line 1 72 0 0 7


    int16  cdecl  TIMER_call (void cdecl (* handler) (void),
                               int16 install_code);


Function :
   Install and deinstall handlers for timer interupt events.


High level protocols very often require a function to be executed on a
regular basis. As the STinG core is called regularly, it can be asked to
execute a user specified function too. This call is used to install or
deinstall those functions, which are called like timer interupt handlers
then. They are called each time STinG polls the ports for sending and
receiving data.

The installed function is called from the main interupt, thus may use
only a very limited amount of CPU time. Hence waiting for any event is
not allowed. The call is done asynchronously in Supervisor mode, thus
care must be execised with using any operating system call within the
handler function.

The `install code' can be

   HNDLR_SET :
   HNDLR_FORCE :
        Unlike @{"IP_handler" LINK "The `IP_handler' Function"}, with TIMER_call these codes have the same
        meaning. They install another timer interupt callback function.
        Returns TRUE, if successfull, and FALSE, if there was a memory
        problem, or the function has been installed before.

   HNDLR_REMOVE :
        Declare a handler, that has been installed earlier, as invalid.
        This handler won't be called anymore. This must be done when a
        program that installed a handler, terminates. Returns FALSE if
        the specified handler was not installed.

   HNDLR_QUERY :
        Inquire whether the specified handler is installed, without
        changing it. Returns TRUE if it is there, and FALSE, if not.

@endnode


@node "The `TIMER_now' Function"
@symbol ar "TIMER_now"
The `TIMER_now' Function                                           STinG
@line 1 72 0 0 7


    int32  cdecl  TIMER_now (void);


Function :
   Returns the number of milliseconds elapsed since last midnight.


For timing processes, a timebase is required. This function provides a
timebase in milliseconds, with a resolution of five milliseconds. That
means the return value is a multiple of five. The value is in the range
from zero (inclusive) to 86,400,000 (exclusive).

@endnode


@node "The `TIMER_elapsed' Function"
@symbol ar "TIMER_elapsed"
The `TIMER_elapsed' Function                                       STinG
@line 1 72 0 0 7


    int32  cdecl  TIMER_elapsed (int32 moment);


Function :
   Calculates the number of milliseconds elapsed since a given moment.


For timing processes, time intervals must be measured. The procedure is
to inquire the time via the @{"TIMER_now" LINK "The `TIMER_now' Function"} call, when the process has started,
and feeding the resulting value into TIMER_elapsed when the process has
finished. The TIMER_elapsed call returns the time interval in millise-
conds, again with a resolution of five milliseconds.

Note that the return value is always modulo the past 24 hours. So if a
value is fed into TIMER_elapsed that lies in the future, it will just be
treated as if the same moment 24 hours earlier was meant. The same holds
if moments are passed that are earlier than 24 hours ago.

@endnode


@node "The Routing Manager"
The Routing Manager                                                STinG
@line 1 72 0 0 7

The Routing Manager contains all the functions that are used to query and
manipulate the routing table. Resetting the routing table is accomplished
by reloading it.

These calls are :

    int16  cdecl  @{"load_routing_table" LINK "The `load_routing_table' Function"} (void);
    int16  cdecl  @{"get_route_entry" LINK "The `get_route_entry' Function"} (int16, uint32 *,
                                   uint32 *, PORT **, uint32 *);
    int16  cdecl  @{"set_route_entry" LINK "The `set_route_entry' Function"} (int16, uint32,
                                   uint32, PORT *, uint32);
@endnode


@node "The `load_routing_table' Function"
@symbol ar "load_routing_table"
@next "The Routing Table"
The `load_routing_table' Function                                  STinG
@line 1 72 0 0 7


    int16  cdecl  load_routing_table (void);


Function :
   Reloads the IP core routing table.


The function just causes the IP core to load again the routing table from
the file "@{"ROUTE.TAB" LINK "The Routing Table"}". It must be located in the @{"STinG directory" LINK "STinG Directory"}.

Returns E_NORMAL, or E_NODATA (problems reading the file), or E_NOMEM.

@endnode


@pnode "STinG Directory"
The directory STinG loads all DEFAULT.CFG, ROUTE.TAB and
*.STX modules from. It is specified by the STING.INF file
that accompanies STING.PRG in the AUTO folder. This file
contains one line with the path to the mentioned directory.
@endnode


@node "The Routing Table"
@prev "The `load_routing_table' Function"
The Routing Table                                                  STinG
@line 1 72 0 0 7

The routing table is a set of parameters for the router, that enables it
to determine which port is to be used for passing on a datagram. To that
end the core uses the destination IP address of the datagram, and works
through the table to find a suitable entry. For each entry the IP address
will be ANDed with the subnet mask and the result compared to the subnet
address. In the case of equality the entry provides the port the datagram
will be forwarded to, and a gateway, to be used in case the destination
host cannot be reached directly via that port.

The contents of the routing table are loaded from the file ROUTE.TAB from
the @{"STinG directory" LINK "STinG Directory"}. It is a human readable ASCII format text file. Each
line that does not start with digits is ignored. From the remaining lines
each one with consistent information forms a single entry for the routing
table, called a "route". The lines contain four entries, separated by @{B}TAB@{b}
characters (ASCII 9). Spaces must not be used to separate entries ! This
is for having spaces available for data. The four entries are :

  - First the network (subnet address) which can be reached by using this
     route.
  - Next the subnet mask associated with that network.
  - Then the port name follows. This is the name like listed by ConfSTinG
     or STNGPORT.CPX.
  - Last entry is the IP address of a host on the attached network that
     can act as a gateway. For point to point connections this entry can
     be set to any arbitrary address.

The network specified may be directly attached to the specified port, in
that case no gateway is needed, as the datagram can be routed directly.
For a route to a network that is directly attached therefore the gateway
entry should be set to 0.0.0.0. For routes to non-local networks a gate-
way within the attached local network must be specified. If the local net
is an Ethernet, the gateway entry specifies the gateway out of the Ether-
net, for a serial line it is simply the host at the other end.

It is advisable to finish the table by a default route. This route is most
easily obtained by specifying a network 0.0.0.0 with a netmask of 0.0.0.0.
Routes with invalid addresses or absent ports are ignored.

An example ROUTE.TAB file contains the following lines :

192.68.0.0            255.255.255.240       Modem 1       192.68.0.1
130.75.75.16          255.255.255.255       Serial 2      0.0.0.0
0.0.0.0               0.0.0.0               Serial 2      130.75.75.16

Here we have a point to point connection to the host 192.68.0.1 via the
Modem 1 port, this host is part of the network 192.68.0.0. Any host on
that network can be reached via Modem 1. The next line specifies a single
host 130.75.75.16 at the other end of the point to point connection via
SERIAL2. The last line is the default route that will be used if none of
the other entries fit. Normally this is the route out into the Internet.
The beforementioned host 130.75.75.16 acts as a gateway at the other end
of the point to point connection at SERIAL2.

@endnode


@node "The `get_route_entry' Function"
@symbol ar "get_route_entry"
The `get_route_entry' Function                                     STinG
@line 1 72 0 0 7


    int16  cdecl  get_route_entry (int16 index, uint32 *subnet,
                              uint32 *submask, PORT **port, uint32 *gateway);


Function :
   Inquires about an entry in the routing table.


An entry in the routing table can be read by passing it's index into the
table in `index', and providing pointers to variables to which the parts
of the entry are to be written. The parts of the entry follow the scheme
that is employed in the file "@{"ROUTE.TAB" LINK "The Routing Table"}" too.

Returns the current number of entries, or -1 if `index' is out of range.

@endnode


@node "The `set_route_entry' Function"
@symbol ar "set_route_entry"
The `set_route_entry' Function                                     STinG
@line 1 72 0 0 7


    int16  cdecl  set_route_entry (int16 index, uint32 subnet,
                              uint32 submask, PORT *port, uint32 gateway);


Function :
   Modifies or adds an entry to the routing table.


An entry in the routing table can be modified using this call. The index
of the entry to be modified is passed in `index'. Also the routing table
can be extended by adding a new entry. Pass -1 for `index' in that case.

The new contents of the entry are passed in `subnet', `submask', `port'
and `gateway'. These contents are the same as in the lines in the file
"@{"ROUTE.TAB" LINK "The Routing Table"}". The recommended procedure is to use @{"get_route_entry" LINK "The `get_route_entry' Function"} to read
the contents, modify them, and write them back using set_route_entry.

Returns -1 if `index' is out of range, or the routing table was full. If
an entry was succesfully modified or added, the index of the entry is
returned.

@endnode


@node "Pure C Patch Instructions"
Pure C Patch Instructions                                          STinG
@line 1 72 0 0 7

The Pure User Shell and the Pure Debugger change the privilege violation
exception vectors to their own handlers in order to provide the developer
with useful information when a privilege violation exception occurs. This
however interferes with some STinG internal protection mechanism. To pre-
vent PC and PD from changing the vectors, instructions given herein must
be carried out. Read this text and you can create your own patched Pure C
setup. The command-line compiler version does not need to be patched.

Before you start: MAKE A COPY OF PD AND PC AND WORK ON THE COPIES. ONCE
CHANGED, DATA IS VERY DIFFICULT TO RESTORE.

Warning : This patch is working fine for me, but it might not work on your
          machine.

This patch has been tested with the following versions of PC and PD:

   PC: version 1.1   Mar 20 1993   (231986 bytes)
   PD: version 1.1   Jan 22 1993   (150805 bytes)
   PD: version 1.1   Jan 22 1992   (150785 bytes)

   TC: version 1.0   1988   (Turbo C)
   TD: version 1.0   1990   (Turbo Debug)

Check the version first. If you have a different version, things may be
different. This does not mean that you can't patch your version. It means
WATCH OUT and DON'T make changes if you're not sure.

To apply the patch, you will need a disk editor or any other kind of pro-
gram that lets you modify binary code. The program must be able to look up
a combination of bytes and, very important if you don't use a disk editor,
it must be able to load a program without relocating the code so that you
can save the changes you made (binary load/save). I used KnifeST for all
changes.

A disassembler is also very handy so that you can check the code changed
by the @{"User Shell patch" LINK "The Pure C User Shell Patch"}. PD will do the job of course.

Now follow the instructions for patching both the @{"Pure User Shell" LINK "The Pure C User Shell Patch"} and the
@{"Debugger" LINK "The Pure C Debugger Patch"} closely.

If you have any questions, just contact me.

Eabe Kuik
merciful@@worldaccess.nl

Happy debugging !!!

@endnode


@node "The Pure C Debugger Patch"
The Pure C Debugger Patch                                          STinG
@line 1 72 0 0 7

The Pure Debugger is using a table to look up the vectors to install. If
an entry in this table is zero it will skip this vector.

Look for the following word combination in PD.PRG (in the data segment):

   0000 0000 0080 008C 0098 00E6 00F2 00FE
   010A 0142 0268 0000 0000 0160 016C 0000
   0000 0000 0000 0000 0000 0000 0000 0000
   0178 0000 0000 0000 0000 0000 0000 0000

This is the table it's using. Word 0 is for vector 0, word 1 for vector 1
and so on (vector 2 is bus error). All what needs to be done is changing
word 8 (010a) to 0000.

   0000 0000 0080 008C 0098 00E6 00F2 00FE
   0000 0142 0268 0000 0000 0160 016C 0000
   0000 0000 0000 0000 0000 0000 0000 0000
   0178 0000 0000 0000 0000 0000 0000 0000

The table should look like the latter one now. Save it and your patched
Debugger is ready for work.

@endnode


@node "The Pure C User Shell Patch"
The Pure C User Shell Patch                                        STinG
@line 1 72 0 0 7

The patch to apply to the User Shell is a bit dangerous, because program
code has to be changed. So be very carefully !!!

Look for the following word combination in PC.PRG (in the text segment):

   $3F3C $0008 $3F3C $0005 $4E4D

You should find the following words (COMPARE THE CODE. IT MUST BE EXACTLY
THE SAME !!!!) :

   487A 0110 3F3C 0008 3F3C 0005 4E4D 504F
   23C0 xxxx xxxx 47FA 0062 284B 4BF9 xxxx

Note 1: [xxxx] is a word that will be different on disk.

Note 2: words 47fa -> 4bf9 are provided only so that you can verify if
        you're at the correct position in the program. If these words
        are not there, you're at the WRONG location (find next may work).

This is the starting point where the pv exeption vector gets modified.
The code looks like this:

   PEA      pv_vector(PC)                 487A 0110
   MOVE.W   #$0008,-(A7)                  3F3C 0008
   MOVE.W   #$0005,-(A7)                  3F3C 0005
   TRAP     #13                           4E4D
   ADDQ.W   #8,A7                         504F
   MOVE.L   D0,Save_vec                   23C0 xxxx xxxx

Now change it to the following (change first 8 words):

   4E71 4E71 4E71 4E71 4E71 4E71 4E71 70FF
   23C0 xxxx xxxx 47FA 0062 284B 4BF9 xxxx

After you've done it, write it back. The code now will look like this:

   NOP                                    4E71
   NOP                                    4E71
   NOP                                    4E71
   NOP                                    4E71
   NOP                                    4E71
   NOP                                    4E71
   NOP                                    4E71
   MOVEQ    #$FF,D0                       70FF
   MOVE.L   D0,Save_vec                   23C0 xxxx xxxx

The moveq instruction is very important. This ensures that the vector
stays unchanged when PC is deinstalling vectors.

Save it and your patched Pure User Shell is ready for use.

@endnode
