@node "STinG Modules"
@prev "STinG Modules"
STinG Modules                                                      STinG
@line 1 72 0 0 7


  Low level port driver modules :

     @{"SERIAL.STX" LINK "SERIAL.STX : Serial Line Networking"}
     @{"CEN_PLIP.STX" LINK "CEN_PLIP.STX : Parallel Line Internet Protocol"}
     @{"CEN_PLEP.STX" LINK "CEN_PLEP.STX : Parallel Line Enhanced Protocol"}
     @{"ETHER.STX" LINK "ETHER.STX : Heyyya, This is Fast !"}
     @{"MIDI.STX" LINK "MIDI.STX : Musical Networking"}
     @{"LCLTLK.STX" LINK "LCLTLK.STX : Atari Bites the Apple"}
     @{"MASQUE.STX" LINK "MASQUE.STX : Carnival on the Net"}


  High level protocol modules :

     @{"TCP.STX" LINK "TCP.STX : Transmission Control Protocol"}
     @{"UDP.STX" LINK "UDP.STX : User Datagram Protocol"}
     @{"RESOLVE.STX" LINK "RESOLVE.STX : The DNS-Resolver"}

@endnode


@node "SERIAL.STX : Serial Line Networking"
SERIAL.STX : Serial Line Networking                                STinG
@line 1 72 0 0 7

The driver SERIAL.STX supplies driving code for all serial ports
on Atari computers. It recognizes all standard ports from ST, STE,
Mega STE, TT and Falcons. The Midi port is treated as a serial
port too. All additional port hardware, provided OS-level drivers
are installed into BIOS and an RSVF descriptor exists, is recognized
too and can be used just like the standard ports. BIOS and RSVF
installation is done by the HSMODEM drivers, for instance.

The names of the standard ports are as follows :
XXXX ST     :   "Modem 1", "Midi"
1040 STE    :   "Modem 1", "Midi"
Mega STE    :   "Modem 1", "Modem 2", "Ser.2/LAN", "Midi"
TT          :   "Modem 1", "Modem 2", "Serial 1", "Ser.2/LAN", "Midi"
Falcon      :   "Modem 1", "Modem 2", "LAN", "Midi"
Note that you need to do a little hardware work to be able to use
Modem 1 on a Falcon. The Falcon port that is labeled "Modem" on the
case is "Modem 2".

If this driver is to be used under a TOS version that does not support
Bconmap() in XBIOS (if you use a TOS 1.x then this is most probably
the case) then HSMODEM or an equivalent package *must* be installed.
To check for this, simply have STinG load this driver, and look into
the STNGPORT.CPX, or run ConfSTinG from the desktop, or check whether
Modem 1 is there. Modem 1 should be shown available on every machine,
even the Falcon. If it isn't on yours, you must install HSMODEM.

If you want to use Midi for serial point to point networking then you
must install HSMODEM too. Note that you won't find a Midi entry in
STNGPORT.CPX or ConfSTinG if you haven't got HSMODEM installed. Do not
confuse this with MidiNet, which is a Midi based ring network that
brings it's own driver, as HSMODEM MIDI.PRG can't be used for it.

If HSMODEM is used on a TT or Mega STE to control the SCC ports
("Modem 2" and "Ser.2/LAN") then the HSMODEM SCC.PRG variable "LANBIT"
should be set to "Yes".

@endnode


@node "CEN_PLIP.STX : Parallel Line Internet Protocol"
CEN_PLIP.STX : Parallel Line Internet Protocol                     STinG
@xref "cen_plip.hyp/Main" "CEN_PLIP.STX"
@line 1 72 0 0 7

 Documentation for Cen_PLIP.Stx version 1.19
 Created by Ulf Ronald Andersson

 @{U}Contents@{u}

 @{"Introduction" LINK "Cen_PLIP : Introduction"}
 @{"Installation" LINK "Cen_PLIP : Installation"}
 @{"Making a PLIP/PLEP cable" LINK "Cen_PLxP : Making a PLIP/PLEP cable"}

 @{"cntrl_port interface" LINK "Cen_PLIP : cntrl_port interface"}
 @{"Development History" LINK "Cen_PLIP : Development History"}
 @{"Feedback" LINK "Credits and Copyright"}
@endnode


@node "Cen_PLIP : Introduction"
Cen_PLIP : Introduction                                            STinG
@line 1 72 0 0 7

Cen_PLIP.Stx is a STinG module which implements a  PLIP port compatible to
those used with  MintNet. (For which PLIP was invented.)  This now gives a
normal  ST  the possibility of using  much higher transfer speed for local
networking, thanks to the use of a parallel port.

The name of this port is "Centr. PLIP", and it is these 11 characters that
you must enter as 'port name' in  ROUTE.TAB to configure routes for  PLIP.
The name was chosen to remain unique if other PLIP drivers for other ports
are created, or if other drivers are made for the centronics port.

The effective speed is limited by other factors of course, so having a lot
of servers and clients constantly active may lower this efficiency, but no
port can be immune to this effect.  The STinG timeslice also affects the
rate at which packets are handed to clients, and thus the overall speed.

Using PLIP to connect my F030 via my TT030 (using Masque.Stx) to internet,
both machines supply their clients with data at  virtually the same speed.
The speed limit then is actually set by the modem, since PLIP is very much
faster than the 28K8 modem I have.

The full speed of  PLIP will only be utilized when using a direct network,
so that no modem imposes a lowered speed limit on any transfers.  Even an
unaccelerated ST will achieve  TCP  rates in excess of 4500 cps, and even
higher rates for simpler protocols.

To me, this makes local networking truly enjoyable, to a degree that could
never quite be matched using Midi, which is what I had to use before.  The
many  musicians that use  Ataris  should also welcome the ability to use a
fast networking port which does not interfere with their  Midi  equipment.

@endnode


@node "Cen_PLIP : Installation"
Cen_PLIP : Installation                                            STinG
@line 1 72 0 0 7

PLIP.STX must of course be stored in the STinG module folder, with the rest.
Then you need to reboot so that  STinG  loads the new module so that you can
configure it, which is done in the usual way with STNGPORT.CPX

PLIP is a very simple protocol, identical to pure SLIP,  with the difference
of using a  parallel interface rather than a  serial one.   Because it is so
simple there is no need to configure anything  else than the  IP number, the
MTU size, and the activation flag.

To actually make  use of the port,  you must of course also edit your  route
file  ROUTE.TAB, to include at least one entry for the port  "Centr. PLIP".

For a  'slave' unit that needs to access a  'master' unit over PLIP so as to
get  indirect access to  internet (requires Masque.Stx), you do not need any
other entries than the one for  PLIP, which should then have  0.0.0.0 in all
the IP number/network fields.  Like this:

0.0.0.0     0.0.0.0     Centr. PLIP 0.0.0.0

For the master unit the "Centr. PLIP" entry needs to be a small subnet spec,
and could look like this:

1.0.255.0   255.255.255.0   Centr. PLIP 0.0.0.0

Remember that this line must come before the default route, used for the
internet connection, since the file may not be processed below that line.


There are two things which are noteworthy of the last example above:

1:  That network uses addresses which will not be used by internet.
    This means there can never be any conflict.

2:  You will need to use an IP address of the form 1.0.255.xxx  for any
    machine to be reached through this subnet entry.  This particularly
    includes the "PLIP" port of the  'slave'  unit, and it is advisable
    to use a related number for that on the  'Master'  unit too.

@endnode


@node "Cen_PLxP : Making a PLIP/PLEP cable"
Making a PLIP/PLEP cable                                           STinG
@line 1 72 0 0 7

The necessary connections:
--------------------------

Essentially a PLIP cable is an RS232 cable with some lines unconnected, and
one pair of lines crossed (like in a null-modem).  Only 11 lines need to be
used, since lines 18-24 are duplicate ground lines.  I recommend using them
too, to minimize grounding problems, but that is up to you.

The necessary connections are specified as one connecting line per character
row in the diagram below:

        DB-25           DB-25
        Unit A          Unit B
    ---------------     ---------------
      pin   name          pin   name
      ---   ----          ---   ----
       1    STROBE         11   BUSY
       2    D0              2   D0
       3    D1              3   D1
       4    D2              4   D2
       5    D3              5   D3
       6    D4              6   D4
       7    D5              7   D5
       8    D6              8   D6
       9    D7              9   D7
      11    BUSY            1   STROBE
      25    GROUND         25   GROUND

Pins 12-17 should be unconnected, and pins 18-24 are extra grounds.

As you can see from the tables  above,  it is a very simple matter to make a
PLIP cable from a leftover RS232 flat-cable.  Just cut away lines 12 to 17
completely and simply cut lines 1 and 11 so you can cross connect them.
(Splice them with some of the surplus wire from lines 12 to 17 just removed)

NB: Remember that DB-25 connectors do *NOT* number the pins in the same
    order that they appear on a flat cable. The numbers given are all DB-25!
    So pins 1 and 2 are not adjacent in the cable, but have pin 14 between.

Important !!!  The lines to cut away are thus *NOT* a block of adjacent ones.


This was the easy way !  Now for the *BETTER* way.

Keep you RS232 cable intact and make a small adapter from two leftover DB-25
connectors instead.   This also gives you the opportunity to add  protection
for the main port driving chip (The PSG of your computer).  This helps avoid
damage when both ports are set as outputs with the cable connected.

NB:  This happens *EVERY* time both computers are switched on, or reset.

This protection simply consists of low value (not too low) resistors, placed
in series with each of the data lines.  I used 75 Ohm resistors.  If you use
lower resistors,  the protection is decreased,  but using much higher values
will interfere with signal transfer levels.  I advice 50-100 Ohms as limits.

The resistors together with normal circuit capacitance also form lowpass pi-
filters that help eliminate signal reflection and 'ringing',  to keep signal
logic levels reliable.

Regardless of which method you use,  do be  careful  to avoid shortcircuits,
and make sure everything gets properly isolated.   Any  damage you may cause
is your own responsibility, and since the PSG fills many important functions
(not just sound) in the computer, your system will not work without it.

I have myself let the cable remain connected  since I completed the adapter,
but you must choose what to do for yourself.  I am not responsible for that.

NB: Using a separate adapter, thus keeping your cables intact, allows you
    to also use the same cables for other things. Such as for example the
    normal RS232 ports, or the PLMP interface I plan to release shortly.
    (PLMP = Parallel Line Multidrop Protocol.)  The latter will require a
    different adapter from PLIP, but will use the same ports and cables.

@endnode


@node "Cen_PLIP : cntrl_port interface"
Cen_PLIP : @{"cntrl_port" LINK "The `cntrl_port' Function"} interface                                    STinG
@line 1 72 0 0 7

This Cen_PLIP version was developed for the STinG kernel Beta releases in
the summer of 1998, and it will therefore not work properly with any of
the older kernels. This is the case for all port drivers, since the driver
structure has been changed to include a new function used by the kernel to
implement the new @{"API" LINK "API"} function '@{"cntrl_port" LINK "The `cntrl_port' Function"}' for safe access to port data.

Cen_PLIP currently supports the following @{"cntrl_port" LINK "The `cntrl_port' Function"} opcodes:

CTL_GENERIC_SET_IP  =>  Set IP number of the port
CTL_GENERIC_GET_IP  =>  Get IP number of the port
CTL_GENERIC_SET_MTU =>  Set MTU size of the port
CTL_GENERIC_GET_MTU =>  Get MTU size of the port
CTL_GENERIC_GET_MMTU    =>  Get Max MTU size of the port
CTL_GENERIC_GET_TYPE    =>  Get port link type of the port
CTL_GENERIC_GET_STAT    =>  Get port transfer statistics
CTL_GENERIC_CLR_STAT    =>  Clear port transfer statistics

These functions are very tolerant of input data, so they accept almost any
values, even if these will not give functional results.  This means it is
the responsibility of the calling program to avoid nonfunctional values !

Error codes possible:

E_PARAMETER will result if anyone calls the cntrl function in the driver
without setting up the port pointer like the kernel does.  That will not
happen if you call the '@{"cntrl_port" LINK "The `cntrl_port' Function"}' @{"API" LINK "API"} function correctly, because then
the kernel will find the port structure itself. (You use the port name.)

E_PARAMETER will result if CTL_GENERIC_SET_MTU is called with an MTU value
that is higher than the maximum allowed for the port (8192).

E_FNAVAIL will result if any opcode other than those listed above are used.
@endnode


@node "Cen_PLIP : Development History"
Cen_PLIP : Development History                                     STinG
@line 1 72 0 0 7

 @{U}Version@{u}        @{U}Details@{u}

 1.19       1999 October 10
        Finally it seems that the PLIP driver for STinG works
        the way it should.  At least it has not failed for me
        yet, and judging from the ease of operation this does
        seem to run reliably now.  So I will release this now.
        Please report any problems with it to me ASAP.

 1.12-1.18  1999
        After discovering that none of the previous versions
        worked as intended, I almost dropped this project, but
        continued working on it without releases, due to innate
        inability to give up.  (What ?  Me stubborn...?  ;-)

 1.11       1998 December 14
        Some small changes in the source plus a major correction
        of one macro library motivate this release.  The bug in
        the macro library (due to translation from PASM dialect)
        does explain some of the problems encountered before.

 1.10       1998 September 8
        Some problems still remain, but a new release is still
        necessary due to changes in the STinG kernel. It has
        also been discovered that PASM could not cope with all
        the needs of the macro libs due to its 1-pass design.
        All source code (incl all libs) have therefore now been
        translated to DevPac dialect.

 1.09       1998 May 24
        The problems of 1.08 have now been debugged (I hope ;-),
        and this resulting version now runs well on my systems.
        The speed has been raised to an average of 9000 cps for
        most networking, with peaks of appx twice that speed. As
        before, these figures relate to communication between a
        Standard Falcon and a 16 MHz ST.  Other system speeds
        will naturally affect any results of your own.

 1.08       1998 March 31
        This version was an attempt to raise speed and safety by
        restructuring the interrupt code (again).  Results were a
        bit dubious though, so this version was not released.

 1.07       1998 February 12
        After 48 hours nearly continuous work at speed optimization
        this version has now achieved bulk transfer rates averaging
        at 6100 cps (equivalent to serial 61000 bps), when browsing
        from a 16 MHz Mega ST4 running @{"CAB" LINK "CAB"} 2.7 + CAB.OVL 1.2805 to
        access pages/files on a 16 MHz falcon running SHTTPD 2.2.
        This is good enough to release, though I still expect more!


 1.06       1998 February 10
        After some necessary STinG Kernel improvements last November
        the PLIP module lost all reliability.  It has been a long
        struggle to get it back online, but here it is, the first
        Cen_PLIP version running perfectly under the latest STinG.
        This was achieved at cost of speed though, so this version
        is not released.  Who wants PLIP at 1000 cps...?  :-(

 1.05       1997 October 25
        Added module basepage pointer to @{"DRIVER" LINK "DRIVER"} structure.
        This is a new standard defined to ease debugging.


 1.04       1997 October 13
        Rewritten to use a new form of interupt masking, to improve
        transfer rates and decrease errors due to kernel interrupts
        interfering with PLIP timing.

        Renamed to "Centr. PLIP" with filename "CEN_PLIP.STX", after
        long discussions with Peter on naming conventions. This will
        not collide with any future port.


 1.03       1997 September 13
        Rewritten to take advantage of the new capabilities of the
        latest STinG kernel to allow kernel routines to be called
        from hardware interrupts.  This removes an unpleasant limit
        on the number of packets tranferred per timeslice.  Even an
        unspeeded ST can expect TCP rates in excess of 4500 cps now.
        (Tested with MTU=576, MSS=536. Higher values = higher speed)

 1.02       1997 August 25
        A bug that sometimes locked up the system has been killed.
        This is the first proper release version, and test runs on
        it include bidirectional 'Pinging' of 4500 datagrams.
    NB: No tests have yet been made with 'partners' using MintNet,
        so reports on results with such would be appreciated.

 1.01       1997 August 22
        The fatal bug mentioned below has been exterminated.
        The statistics counter for dropped packets is corrected.
        Statistics counters for sent/received data are implemented.
        The document is now in ST-Guide hypertext format.

 1.00       1997 August 22
        First functional version, with one FATAL bug that could
        kill unrelated MFP interrupts...

 0.xx       1997 August 18-21
        Project start and various experiments

@endnode


@node "CEN_PLEP.STX : Parallel Line Enhanced Protocol"
CEN_PLEP.STX : Parallel Line Enhanced Protocol                     STinG
@line 1 72 0 0 7

 Documentation for Cen_PLEP.Stx version 1.00
 Created by Ulf Ronald Andersson

 @{U}Contents@{u}

 @{"Introduction" LINK "Cen_PLEP : Introduction"}
 @{"Installation" LINK "Cen_PLEP : Installation"}
 @{"Making a PLIP/PLEP cable" LINK "Cen_PLxP : Making a PLIP/PLEP cable"}

 @{"cntrl_port interface" LINK "Cen_PLEP : cntrl_port interface"}
 @{"Development History" LINK "Cen_PLEP : Development History"}
 @{"Feedback" LINK "Credits and Copyright"}
@endnode


@node "Cen_PLEP : Introduction"
Cen_PLEP : Introduction                                            STinG
@line 1 72 0 0 7

Cen_PLEP.Stx is a STinG module implementing Parallel Line Enhanced Protocol.
This uses the Centronic port in ways somewhat similar (identical cables) to
how it can also be used by the PLIP protocol, over which it has some rather
important advantages.

1:  PLEP uses a different modulation of the Strobe/Busy lines, to allow
    both ends the ability to break in and tell the other about errors.
    With PLIP the only way to do so was to stop ACKing and let the other
    party time out, which wasted a lot of time.

2:  A PLEP receiver that needs to send data can prevent the other party
    from 'hogging' the channel, and demand it for its own sending, and
    this can be done without undue delay.  (A few microseconds.)  That
    enhancement too is due to the different Strobe/Busy modulation.

3:  At end of a packet PLEP lets the receiver confirm reception, based
    on a 16-bit CRC (not checksum, but real CRC) including the entire
    IP packet. Thus faulty data is never (well almost never) delivered.

4:  PLEP uses an encoding method which ensures that neither $00 nor $FF
    can ever be transmitted as legal commands or data.  Thus any locked
    levels (by hardware faults) can not lead to faulty commands or data.
    The same encoding also ensures that data blocks will never contain
    any bytes that can be taken as commands, or vice versa.

Tests so far with comparable PLEP and PLIP implementations, meaning that
appx 90% of the code is identical, with only the necessary differences in
the interrupt routines,  show that PLEP will normally be faster than PLIP
even though it performs more work. This is because the PLIP protocol uses
a Strobe/Busy modulation method that inevitably wastes time.

The only drawback of this protocol that I am aware of is that it is not a
standard protocol used by any other system.  So if you want to connect the
Centronic port to a Linux box or MintNet then you need to use Cen_PLIP.Stx
instead of Cen_PLEP.Stx, as those machines only have standard PLIP.  But
for connection of only machines running STinG I prefer this Cen_PLEP.Stx.

The name of this port is "Centr. PLEP", and it is these 11 characters that
you must enter as 'port name' in  ROUTE.TAB to configure routes for  PLEP.
The name was chosen to remain unique if other PLEP drivers for other ports
are created, or as other drivers are made for the centronics port.
(At present we have both PLIP and PLEP, and plans exist for PLMP.)
@endnode


@node "Cen_PLEP : Installation"
Cen_PLEP : Installation                                            STinG
@line 1 72 0 0 7

CEN_PLEP.STX must be stored in the STinG module folder, as all STX modules.
Then you need to reboot so STinG will load the new module,  so that you can
configure it, which is done in the usual way with STNGPORT.CPX

PLEP is a fairly complex protocol, but its complexities are kept where they
belong, inside the interrupt routines where the normal user never sees them.
Because of this there is no need to configure anything  other  than the  IP
number, the MTU size, and the activation flag.

To actually make  use of the port,  you must of course also edit your  route
file  ROUTE.TAB, to include at least one entry for the port  "Centr. PLEP".

For a  'slave' unit that needs to access a  'master' unit over PLEP so as to
get  indirect access to  internet (requires Masque.Stx), you do not need any
other entries than the one for  PLEP, which should then have  0.0.0.0 in all
the IP number/network fields.  Like this:

0.0.0.0     0.0.0.0     Centr. PLEP 0.0.0.0

For the master unit the "Centr. PLEP" entry needs to be a small subnet spec,
and could look like this:

1.0.255.0   255.255.255.0   Centr. PLEP 0.0.0.0

Remember that this line must come before the default route, used for the
internet connection, since the file may not be processed below that line.


There are two things which are noteworthy of the last example above:

1:  That network uses addresses which will not be used by internet.
    This means there can never be any conflict.

2:  You will need to use an IP address of the form 1.0.255.xxx  for any
    machine to be reached through this subnet entry.  This particularly
    includes the "PLEP" port of the  'slave'  unit, and it is advisable
    to use a related number for that on the  'Master'  unit too.
@endnode


@node "Cen_PLEP : cntrl_port interface"
Cen_PLEP : @{"cntrl_port" LINK "The `cntrl_port' Function"} interface                                    STinG
@line 1 72 0 0 7

This Cen_PLEP version was developed for STinG 1.20 and will therefore not
work properly with any of the older kernels. This is the case for all port
drivers, since the driver structure is changed to include a new function
used by the kernel to implement the new @{"API" LINK "API"} function '@{"cntrl_port" LINK "The `cntrl_port' Function"}' for safe
access to port data.

Cen_PLEP currently supports the following @{"cntrl_port" LINK "The `cntrl_port' Function"} opcodes:

CTL_GENERIC_SET_IP      =>  Set IP number of the port
CTL_GENERIC_GET_IP      =>  Get IP number of the port
CTL_GENERIC_SET_MTU     =>  Set MTU size of the port
CTL_GENERIC_GET_MTU     =>  Get MTU size of the port
CTL_GENERIC_GET_MMTU    =>  Get Max MTU size of the port
CTL_GENERIC_GET_TYPE    =>  Get port link type of the port
CTL_GENERIC_GET_STAT    =>  Get port transfer statistics
CTL_GENERIC_CLR_STAT    =>  Clear port transfer statistics

These functions are very tolerant of input data, so they accept almost any
values, even if these will not give functional results.  This means it is
the responsibility of the calling program to avoid nonfunctional values !

Error codes possible:

E_PARAMETER will result if anyone calls the cntrl function in the driver
without setting up the port pointer like the kernel does.  That will not
happen if you call the '@{"cntrl_port" LINK "The `cntrl_port' Function"}' @{"API" LINK "API"} function correctly, because then
the kernel will find the port structure itself. (You use the port name.)

E_PARAMETER will result if CTL_GENERIC_SET_MTU is called with an MTU value
that is higher than the maximum allowed for the port (8192).

E_FNAVAIL will result if any opcode other than those listed above are used.
@endnode


@node "Cen_PLEP : Development History"
Cen_PLEP : Development History                                     STinG
@line 1 72 0 0 7

 @{U}Version@{u}        @{U}Details@{u}

 1.00       1999 October 10-20
        First conversion from Cen_PLIP 1.19 achieved, by total
        rewrite of the interrupt driven state machine.  Even in
        first attempts this Cen_PLEP driver is both faster and
        more reliable than Cen_PLIP, thus validating the methods.
@endnode


@node "ETHER.STX : Heyyya, This is Fast !"
ETHER.STX : Heyyya, This is Fast !                                 STinG
@line 1 72 0 0 7

This is an Ethernet driver developed by Peter Rottengatter for the
'Riebl' board, based on the LANCE chip.

The documentation for it is not yet merged into the main hypertext.

Other Ethernet drivers have been developed by Vassilis Papathanassiou,
and can be found on his web pages.  (URL in 'Credits and Copyright')

@endnode


@node "MIDI.STX : Musical Networking"
MIDI.STX : Musical Networking                                      STinG
@line 1 72 0 0 7

This module only contains dummy code as yet. I always wanted to do
real networking with the Atari's Midi ports, by connecting many
machines in a ring shaped network. No time to work on it right now,
though.

Ring shaped Midi networks work anyway, using the SERIAL.STX, but that
causes a full packet delay for each node in the rine.  A proper ring
network on the other hand should only give a single byte transfer delay
for each node in the ring, giving much faster delivery in a multi-node
ring.  That is why it is still a good idea to make a Midi-ring module.

@endnode


@node "LCLTLK.STX : Atari Bites the Apple"
LCLTLK.STX : Atari Bites the Apple                                 STinG
@line 1 72 0 0 7

This module only contains dummy code as yet. It's been an early
suggestion by Dan Ackerman. Nobody is working on it right now.

@endnode


@node "MASQUE.STX : Carnival on the Net"
MASQUE.STX : Carnival on the Net                                   STinG
@xref "masque.hyp/Main" "MASQUE.STX"
@line 1 72 0 0 7

 Documentation for Masque.Stx version 1.15
 Created by Ulf Ronald Andersson

 @{U}Contents@{u}

 @{"Introduction to Masque" LINK "Masque : Introduction"}
 @{"Installation of Masque" LINK "Masque : Installation"}
 @{"Configuring Masque" LINK "Masque : Configuration"}

 @{"Masque tool programs" LINK "Masque : Tool programs"}
 @{"Masque cntrl_port interface" LINK "Masque : cntrl_port interface"}
 @{"Masque Development History" LINK "Masque : Development History"}
 @{"Masque Feedback" LINK "Credits and Copyright"}
@endnode


@node "Masque : Introduction"
Masque : Introduction                                              STinG
@line 1 72 0 0 7

Masque.Stx is a STinG module which implements IP masking, so that all of the
computers on a local network can access internet through a single connection
of one of them.  More than one of those computers may have Masque installed,
but only linked to ports that are either passive, or connected to internet
(or another intranet).

For example:

I only have one reasonably fast modem (and only one phoneline), and that is
normally connected to my TT030.  I also have a Falcon030 and a Mega ST4, none
of which have a modem.  These computers are connected as a STinG network and
can all access Internet at the same time, thanks to Masque which is running on
the TT030.  All normal STiK/STinG clients work well with this setup, including
@{"CAB" LINK "CAB"}, Newsie, PopWatch, etc...

However:

For technical reasons there are a few operations that can not work with the
current Masquerade methods, but normally those operations can be replaced by
other means, simply by reconfiguring the client programs.  For example, the
FTP command "@{"PORT" LINK "The `PORT' Structure"}" will not work, but all FTP clients can instead use the
FTP command "PASV" instead, and some of them do that by default anyway.

Incoming requests from clients on Internet to servers running in your local
network can only be handled by one of the local machines.  Normally that is
the machine with the modem, where Masque is active, but this can be changed.

From version 1.15 of Masque it has the ability to treat any local machine
as its 'master'.  A special tool program is included, which will send Masque
a 'master switch' request.  When Masque receives that message it will switch
to regarding the system it came from as the new 'master' machine, which will
thus be able to service requests from Internet, as well as local requests.
@endnode


@node "Masque : Installation"
Masque : Installation                                              STinG
@line 1 72 0 0 7

1:  Copy MASQUE.STX to your STinG STX collection folder on the machine used
    for connecting to the Internet (preferably one with a fast modem port).

2:  Configure masquerading as described in the section on @{"configuration" LINK "Masque : Configuration"}

That's it...
@endnode


@node "Masque : Configuration"
Masque : Configuration                                             STinG
@line 1 72 0 0 7

Configuring Masque has recently become a lot easier,  because it is fully
supported by the STinG Dialer.  This means that you do not need to change
the ROUTE.TAB file to add a Masquerade entry any more. Instead the Dialer
will edit the corresponding route tables in  memory,  as and when needed,
including restoring the routes  after disconnecting.  Thus you can forget
this aspect of Masque configuration from now on.

Even so, to get any benefit from Masque you must have a functional local
network with properly defined ROUTE.TAB files on each of its machines.

Here are some examples and important rules concerning this:

I use the Midi and Plip drivers for local networks and my subnet route
(on a line above the default route) for Midi looks like this:
1.1.2.0     255.255.255.0   Midi        0.0.0.0

On each of the computers using this subnet I have set up the Midi ports
to use the IP addresses 1.1.2.x, with 'x' standing for an arbitrary
machine number unique to each computer in the subnet.

The IP addresses will only be used locally, which is why you can choose
arbitrarily,  but if you use any that correspond with real addresses on
Internet you will  not be able to access those real addresses even when
connected to Internet, since STinG's router will use the local ones.

On a very simple network the machines not connected to the dial-up modem
can manage with a single default route allowing them to reach the modem-
connected machine, and such a route should then look like this:
0.0.0.0     0.0.0.0     Midi        0.0.0.0

But the modem-connected machine _must_ have the local route defined as a
subnet  (see further above)  since its default route after  dial-up will
lead to Internet  (via Masquerade port and modem port).  If you only use
a  default route on this machine too,  then contact with the other local
machines will be lost during dial-up connections.

And remember that default routes (with all those zeroes) must be placed
after any  subnet route definitions,  because  routing is done from the
top down in ROUTE.TAB,  so stuff below the default route is never used.

Using a simple default route without other subnets,  like above,  means
that all packets addressing ports on other computers  will be sent over
Midi in the hope that whoever receives it will be able to pass it on to
someone else etc, in such a way that it eventually does reach the final
recipient through an unknown number of intermediaries.

This routing is naturally done in the same way,  regardless of whether
the packets originated on the local machine or arrived on some port...

In case you didn't know it, this is what IP networking is all about.  ;-)

(Don't laugh guys!  Many smart Internet users have no idea how it works.)


Masque itself is implemented as a STinG port driver, and will therefore
appear in the port list of STNGPORT.CPX, and is configurable from any
modern version of this, or of the dialer.  Modern here means STinG
release 1.08 from late 1997, but newer releases have been made since,
so get those to make sure you have the latest and best drivers.

Settings in the Dialer as usual override any CPX settings when Dialer
establishes a connection, so normally the pseudo port 'Masquerade'
should not be enabled 'manually' in STNGPORT.CPX .  Instead you should
select masquerading in the 'Miscellaneous' section in the 'Configs'
dialog of the Dialer.

Having installed Masque.Stx properly,  you must of course still reboot
the system so as to load the new module in order to configure it. This
can not be done properly without having STinG load it first,  so do it
before proceeding.

Actually you do not need to alter any of the data of the  "Masquerade"
port, because it is written so as to provide sensible defaults for its
settings.  Even so, you should open the CPX and save the settings,  so
they will be included in the STING.PRT file with data for other ports.

The settings include 2 purely local IP addresses, that are used in the
masking work.  Their defaults are  "10.0.255.0" and "10.0.255.1".  The
former is used to mask the  physical port,  while the latter is the IP
address of the Masquerade pseudo port itself. The defaults were chosen
as suggested by  Peter  Rottengatter,  because they can't exist on the
Internet.

Another setting is the max MTU size, with a default of 1500,  which is
a value that should work well with most providers.

Finally there is the choice of port to be masked, which you can set
to be the Modem port that you use.

NB: Let me emphasize again that at dial-up the settings of the Dialer
    will override any settings of the CPX, so you must also make sure
    to save settings into the DIAL.SCR file after editing them in the
    'Configs' dialog in the Dialer.


Once the system has been rebooted with proper 'Masque' setup, and dialer
has established an ISP connection, Masque will take partial control of
the selected port, acting as a filter between it and the internal STinG
functions.  Masque will also 'steal' the IP number of that port whenever
it changes, so dynamic IPs of all kinds should work fine.

Since Masque is a simulated port all data will pass through a physical
port too before reaching the internet, and the MTU value of both ports
should be identical for efficiency reasons and must of course _never_
exceed the maximum MTU value your ISP allows.


NB: An error simple to make is to use STNGPORT.CPX to manually activate
    Masquerade or the  Modem port it should interact with.  This is not
    the proper way to do it !!!  They should always be left passive, so
    for that reason you should never save STING.PRT while connected.
    The CPX  (and its STING.PRT file)  should only be used to  activate
    ports that are intended for LAN usage, not ISP dial-up connections.
    The dialer will activate those as needed when correctly configured.

    Note that the above rule applies even without Masquerade.  It is at
    all times the dialer that should activate any port used for dial-up
    connection to an ISP.
@endnode


@node "Masque : Tool programs"
Masque : Tool programs                                             STinG
@line 1 72 0 0 7

Two extra tool programs are included in the Masque package, and they are:

    MASQLOOK.APP    used to display the true IP a masked connection
    M_MASTER.APP    used to switch 'master' machine in masquerade


MASQLOOK is only useful on the machine where Masqe is active, and it will
simply display an alert box stating whether the masquerade port is active
or not, and if active also stating what the real IP address of the masked
port was before it became masked.  In normal modem connections this means
that it will show the true dynamic or static IP address with which you are
logged on to the Internet, and which other users on Internet must use when
they want to contact servers on your machine directly.  If Masque is not
active, or not even present, then that will be displayed in the alert box
instead.


M_MASTER can be used on any machine in your local network, and it will
then send a special 'Masquerade Master' request through the default
route.  When such a route leads (as it eventually should) to the machine
where Masque is active, then Masque will switch to regarding the sender
as the machine that can interact directly with Internet. It is then that
machine that will be able to receive incoming requests from the Internet,
and which will be able to send certain commands to the Internet that the
other local machines can not do (but they can still use normal commands).
The program will display an alert box stating whether the attempt to set
the new 'Master' succeeded or failed.  If it succeeded, then the true
IP with which you are logged on to the Internet is also shown, just as
for MASQLOOK above.

Note that Masque.Stx will set up the modem machine as 'master' whenever
a dialup connection is made.  To have another machine as 'master' it is
necessary to run M_MASTER on that machine after each dialup.
(ie: After successful completion of the IP link.)


The reason for having both tools is that they use different methods of
finding Masque.  MASQLOOK simply asks STinG to give it the data for the
local copy of Masque (if any).  M_MASTER on the other hand just sends
a packet, hoping that it will reach an active Masque on another machine
which will then send a reply.  The difference is that if anything is
wrong with the routing on any machine in the LAN, then the request or
its reply may get lost, and if Masque is either inactive or missing
then no specific reply will be sent anyway.
@endnode


@node "Masque : cntrl_port interface"
Masque : @{"cntrl_port" LINK "The `cntrl_port' Function"} interface                                      STinG
@line 1 72 0 0 7

STinG now has a new @{"API" LINK "API"} function to access and control ports and as Masque
is implemented as a port, its driver does support that new function.  The
supported '@{"cntrl_port" LINK "The `cntrl_port' Function"}' opcodes are the following:

CTL_GENERIC_SET_IP      =>  Set IP number of Masquerade port
CTL_GENERIC_GET_IP      =>  Get IP number of Masquerade port
CTL_GENERIC_SET_MTU     =>  Set MTU size of Masquerade port
CTL_GENERIC_GET_MTU     =>  Get MTU size of Masquerade port
CTL_GENERIC_GET_MMTU    =>  Get Max MTU size of Masquerade port
CTL_GENERIC_GET_TYPE    =>  Get port link type of Masquerade port
CTL_GENERIC_GET_STAT    =>  Get port transfer statistics
CTL_GENERIC_CLR_STAT    =>  Clear port transfer statistics

CTL_MASQUE_SET_PORT     =>  Set ptr to masked port struct
CTL_MASQUE_GET_PORT     =>  Get ptr to masked port struct
CTL_MASQUE_SET_MASKIP   =>  Set IP address to be used for masking
CTL_MASQUE_GET_MASKIP   =>  Get IP address to be used for masking
CTL_MASQUE_GET_REALIP   =>  Get IP address which is being masked

These functions are very tolerant of input data, so they accept almost any
values, even if these will not give functional results.  This means it is
the responsibility of the calling program to avoid nonfunctional values !

Error codes possible:

E_PARAMETER will result if anyone calls the cntrl function in the driver
without setting up the port pointer like the kernel does.  That will not
happen if you call the '@{"cntrl_port" LINK "The `cntrl_port' Function"}' @{"API" LINK "API"} function correctly, because then
the kernel will find the port structure itself. (You use the port name.)

E_PARAMETER will result if CTL_GENERIC_SET_MTU is called with an MTU value
that is higher than the maximum allowed for the port (8192).

E_UNREACHABLE will result if CTL_MASQUE_GET_REALIP is called when the port
is not active.  Since no masking is done then, no masked IP can exist.

E_FNAVAIL will result if any opcode other than those listed above are used.

A small utilitily program named MASQLOOK.APP is supplied with the Masque
driver, which uses the @{"cntrl_port" LINK "The `cntrl_port' Function"} functions to see if Masque is active
and which 'real IP' it is then masking.  This can be useful to know when
you want someone on Internet to access local servers on your LAN machines.
@endnode


@node "Masque : Development History"
Masque : Development History                                       STinG
@line 1 72 0 0 7

@{U} Version 1.15   1999.11.03  Public release: 2000.07.06 @{u}

    This version was released with the STinG 1.26 release package.
    It contains some internal changes, mainly to allow TCP and UDP
    servers to function better when serving clients on the Internet.
    In most other respects it works the same way as older versions.


@{U} Version 1.14   1998-1999 @{u}

    I performed various experiments with this version(s), but none
    that were released to the public.


@{U} Version 1.13   1998 October 18 @{u}

    Version 1.12 had a bug that prevented proper TCP operation over
    masqueraded connections.  This was due to a mistranslation of
    some constant definitions for TCP header structures and that in
    turn was due to some differing syntax rules of DevPac VS Pasm.

    This problem has now been fixed, so version 1.13 now works as
    well as version 1.11 did. It is however suitable for use only
    with the new STinG versions from 1.20 and on, whereas Masque
    version 1.11 is suitable for use only with older STinG versions.


@{U} Version 1.12   1998 September 8 @{u}

    Added the new driver structure element 'cntrl' used by the kernel
    to implement the new '@{"cntrl_port" LINK "The `cntrl_port' Function"}' @{"API" LINK "API"} function.  A call dispatcher
    was also added to support a number of '@{"cntrl_port" LINK "The `cntrl_port' Function"}' opcodes. This
    is a big change, but an even bigger one is that the source has now
    been converted to DevPac dialect, as has all the support libraries.
    The actual masquerade methods remain unchanged from version 1.11 .


@{U} Version 1.11   1998 March 2 @{u}

    Added a new port structure element holding the masked IP, which is
    normally the ISP dial-up IP needed by some clients for some special
    transfer protocols.  This means it is now possible to find that
    address by careful access of the port structure.  A tool program,
    MasqLook.APP (renameable to ACC/TOS etc) is supplied that uses
    this to present the IP address as text on screen, so that a user
    can pass this to clients etc.  For frequent use I recommend using
    it as an ACC, but for less frequent use I suggest keeping it an APP.


@{U} Version 1.10   1998 January 13 @{u}

    Masking methods modified to allow local servers to be contacted
    by clients on the Internet.

    Hypertext was amended to describe usage with latest STinG.


@{U} Version 1.09   1997 October 25 @{u}

    Added module basepage pointer to @{"DRIVER" LINK "DRIVER"} structure.
    This is a new standard defined to ease debugging.


@{U} Version 1.08   1997 September 7 @{u}

    Partial ICMP support added for 3 (of 6) message classes:

        Incoming error messages for UDP and TCP connections
        Outgoing ICMP requests (echo, timestamp, etc)
        Incoming ICMP replies (echo, timestamp, etc)

    The types now supported are sufficient for the normal PING
    and TRACEROUTE implementations, and tests with those tools
    as implemented both in the dialer and in separate programs
    in the  STinG  release verify this.  All these now work in
    the same way with Masquerade as they do without it.

    The following three message classes are not yet supported,
    and such packets will still merely be dropped and ignored:

        Outgoing error messages for UDP and TCP connections
        Incoming ICMP requests (echo, timestamp, etc)
        Outgoing ICMP replies (echo, timestamp, etc)

    Of those only the first is of any real interest, since the
    others will never occur on a normal ISP connection.

    Undefined/Future ICMP message types are also ignored, which
    is the recommended treatment of such enhancements when they
    can not be properly supported.

    The hypertext was reworked a bit for improved readability,
    and extended with some clues on how to set up a functional
    LAN, for those who are not yet familiar with this aspect
    of STinG.  (Suggested by beta tester Eabe Kuik.)


@{U} Version 1.07   1997 August 21 @{u}

    Port illegality test added, as suggested by Peter


@{U} Version 1.06   1997 August 21 @{u}

    Change of default IP numbers, as suggested by Peter


@{U} Version 1.05   1997 August 20 @{u}

    Bug correction of mislinked masquerade queues


@{U} Version 1.04   1997 August 19 @{u}

    Update for longer port name "Masquerade" requested by Peter


@{U} Version 1.03   1997 August 18 @{u}

    Update for new STinG port type implemented by Peter in
    STNGPORT.CPX and Dialer.


@{U} Version 1.02   1997 August 18 @{u}

    Update for new configuration method suggested by Peter.
    Documentation converted to hypertext.


@{U} Version 1.01   1997 August 14 @{u}

    Update for unblocking time limitation on mask/unmask work


@{U} Version 1.00   1997 August 12 @{u}

    First functional release (to me and Peter only)


@{U} Version 0.xx   1997 August 10-12 @{u}

    Project start and various pre-release experiments

@endnode


@node "TCP.STX : Transmission Control Protocol"
TCP.STX : Transmission Control Protocol                            STinG
@line 1 72 0 0 7

This module installs all TCP specific functions for the STinG @{"API" LINK "API"},
thereby replacing the dummy functions which is all that the kernel
provides for these functions.

Functions in the following two groups are affected:

                    The @{"TCP Manager" LINK "The TCP Manager"}
                    The @{"Connection Manager" LINK "The Connection Manager"}

@endnode


@node "UDP.STX : User Datagram Protocol"
UDP.STX : User Datagram Protocol                                   STinG
@line 1 72 0 0 7

This module installs all UDP specific functions for the STinG @{"API" LINK "API"},
thereby replacing the dummy functions which is all that the kernel
provides for these functions.

Functions in the following two groups are affected:

                    The @{"UDP Manager" LINK "The UDP Manager"}
                    The @{"Connection Manager" LINK "The Connection Manager"}

@endnode


@node "RESOLVE.STX : The DNS-Resolver"
RESOLVE.STX : The DNS-Resolver                                     STinG
@line 1 72 0 0 7

 Documentation for Resolve.Stx version 1.08
 Created by Ulf Ronald Andersson

 @{U}Contents@{u}

 @{"Introduction to the DNS-Resolver" LINK "Resolver : Introduction"}
 @{"Resolver Command List" LINK "Resolver : Command List"}
 @{"Resolver Development History" LINK "Resolver : Development History"}
 @{"Resolver Feedback" LINK "Credits and Copyright"}

@endnode


@node "Resolver : Introduction"
Resolver : Introduction                                            STinG
@line 1 72 0 0 7

Most TCP/IP client programs allow the user to type in IP addresses in the form
of symbolic domain names or numeric (dotted IP) addresses. These are then used
as an argument in calling the resolver module to gain the missing information.
By using a command syntax  illegal for either  symbolic or  numeric addresses,
my resolver module allows such interfaces to be used for commands as well.

The recommended method to use these commands is to do so through the 'Resolve'
tool of the STinG dialer program written by  Peter  Rottengatter.  Using other
client interfaces should also work but may have side effects in those programs.
(Usually causing connection attempts to the IP addresses of stored entries.)

All command keywords begin and end with square brackets ('[' and ']'), and any
unknown sequence starting with a left square bracket will have no effect,  but
will cause the resolver to return the  error code 'E_CANTRESOLVE'.  That  code
will also be returned for any commands that fail, regardless of actual causes.

The reason for this is that some clients test for that error code only.  These
would attempt to use some garbage data if I use another error code, with bombs
resulting from that attempt.  All successful commands will @{"resolve" LINK "The `resolve' Function"} some  cache
entry on completion, to provide a visible indication of the success.  The only
exceptions are [FIRST] and [NEXT] when used so as to get a nonexistent entry.
That will naturally return E_CANTRESOLVE, though there was no real failure.

Blank characters (Tabs and spaces) will be ignored both around and between all
keywords, arguments and separators, but may not be used within such units.

NB: Here period signs ('.') are not considered as unit separators, but rather
    as operators, building full addresses and names from substrings.  Domain
    names and dotted IP numbers are not allowed any internal blanks.
    The only separators currently defined are '=' and ':'

Within the square brackets of a command character case is neither preserved
nor significant, so "[LOAD]" does the same as "[load]" or even "[LoAd]" etc.

@endnode


@node "Resolver : Command List"
Resolver : Command List                                            STinG
@line 1 72 0 0 7

Command list:       Six commands are defined at present

[LOAD]      no argument Loads the CACHE.DNS file into RAM from disk
[SAVE]      no argument Saves the CACHE.DNS file from RAM onto disk
[FIRST]     no argument Resolves the root entry of DNS RAM cache
[NEXT]      no argument Resolves the next entry of DNS RAM cache
[CNAME] arg1 = arg2 : arg3  Defines a canonical domain name for an IP
[ALIAS] arg1 = arg2 : arg3  Defines an alias domain name for an IP

The last two commands have identical syntax and the meaning of argument is:

arg1    The domain name.    eg: hugin.oden.se   (My ISP's main server)
arg2    The dotted IP.      eg: 193.45.240.2    (IP number of the same)
arg3    Time To Live (seconds)  eg: 172800      (valid for two days)

The TTL entry and the preceding ':' are optional, and if excluded a default of
10 years will be used. This is intended for entry of semi-permanent IP numbers
on your local networks, and  allows fully symbolic addresses to be used on any
small  intranet as well as on internet.  No nameserver is needed for this, and
that is important since none is available under TOS as yet.

NB: In order to define an alias, you must *FIRST* define the canonical name of
    that IP number.  Aliases are linked in via the canonical entries, so those
    must exist first.  (This is handled automatically for network queries.)

The two commands [FIRST] and [NEXT] can be used to scan through all entries of
the cache since E_CANTRESOLVE is returned as the end of the cache is reached.

For technical reasons FIRST here means the latest defined CNAME, and the last
entry will be the oldest ALIAS of the oldest CNAME, or that CNAME itself if
the oldest one does not have any aliases.  This is how the cache is organized,
and the scanning order follows this pattern consistently.  Thus aliases are
defined relative to their CNAME, and the order in which they were defined
also relates only to the other aliases of the same CNAME.

Command results as returned to the resolving client program:

keyword     Results
-------     -------
[LOAD]      Resolves the 'root' entry of successfully loaded cache
[SAVE]      Resolves the 'current' entry of the cache on successful save
[FIRST]     Resolves the 'root' entry of the cache, unless it is empty
[NEXT]      Resolves the 'next' entry of the cache, unless already at end
[CNAME]     Resolves the entry defined, if that succeeds
[ALIAS]     Resolves the entry defined, if that succeeds

NB: For safety reasons given in the introduction, all failures of the commands
    will be returned to the calling client as the error code  'E_CANTRESOLVE'.
    That is the only code which ensures that no erroneous data will be used as
    if it was valid, which could lead to 'bombs'.

NB: Since most clients will attempt to make some use of each resolved address,
    I strongly suggest that only the STinG dialer's 'Resolve' tool be used to
    enter the commands.  That is the only client I know of which will never
    use the so resolved addresses on the network.

@endnode


@node "Resolver : Development History"
Resolver : Development History                                     STinG
@line 1 72 0 0 7

Version     Major changes from last version
-------     -------------------------------
  1.08      Corrected a misleading string in an error message.
98.01.19    Revised negative caching of failed inquiries for
        numerical IP's.  The new method will allow proper
        resolving at later date when the resulting dummy
        name has been saved for reuse by a client (hotlists).

  1.07      Added module basepage pointer to @{"LAYER" LINK "LAYER"} structure.
97.10.25    This is a new standard defined to ease debugging.

  1.06      Modified [NEXT] to recognize cache end in user scans
97.09.24    Fixed bug returning E_NOMEM on RAM error to use E_CANTRESOLVE
        Fixed bomber bug in cache that struck ALIASes without CNAMEs
        Added multiple IP return to network DNS queries
        Added multiple caching for DNS queries with multiple results
        Added multiple IP return to DNS cache queries
        Added ICMP error message response, so all LAN machines notice
          when DNS requests to ISP fail due to offline state

  1.05      Removed case sensitivity from command word interpreter
97.09.12    Restructured some caching code

  1.04      Fixed some command bugs
97.08.06    Fixed some caching bugs
        Changed local name ttl default to eternity, to avoid losing
          entries when starting without proper time set.

  1.03      First proper release
97.06.??    Implemented cache commands
        Fixed various bugs
        Restructured some DNS query code

  1.02      First functional version
97.05.??    Combined caching with network queries
        Implemented UDP retries with TCP fallback

 0.00-1.01  Early experimental versions, first by Peter then later by me
  various   These included separately developed code for network queries
        and for the basic cache system (still largely retained).

@endnode
