@node "STinG Modules"
@prev "STinG Modules"
STinG Modules                                                      STinG
@line 1 72 0 0 7


  Low level port driver modules :

     @{"SERIAL.STX" LINK "SERIAL.STX : Serial Line Networking"}
     @{"CEN_PLIP.STX" LINK "CEN_PLIP.STX : Connect Networks Instead of Printers"}
     @{"ETHER.STX" LINK "ETHER.STX : Heyyya, This is Fast !"}
     @{"MIDI.STX" LINK "MIDI.STX : Musical Networking"}
     @{"LCLTLK.STX" LINK "LCLTLK.STX : Atari Bites the Apple"}
     @{"MASQUE.STX" LINK "MASQUE.STX : Carnival on the Net"}


  High level protocol modules :

     @{"TCP.STX" LINK "TCP.STX : Transmission Control Protocol"}
     @{"UDP.STX" LINK "UDP.STX : User Datagram Protocol"}
     @{"RESOLVE.STX" LINK "RESOLVE.STX : The DNS-Resolver"}

@endnode


@node "SERIAL.STX : Serial Line Networking"
SERIAL.STX : Serial Line Networking                                STinG
@line 1 72 0 0 7

The driver SERIAL.STX supplies driving code for all serial ports
on Atari computers. It recognizes all standard ports from ST, STE,
Mega STE, TT and Falcons. The Midi port is treated as a serial
port too. All additional port hardware, provided OS-level drivers
are installed into BIOS and an RSVF descriptor exists, is recognized
too and can be used just like the standard ports. BIOS and RSVF
installation is done by the HSMODEM drivers, for instance.

The names of the standard ports are as follows :
XXXX ST     :   "Modem 1", "Midi"
1040 STE    :   "Modem 1", "Midi"
Mega STE    :   "Modem 1", "Modem 2", "Ser.2/LAN", "Midi"
TT          :   "Modem 1", "Modem 2", "Serial 1", "Ser.2/LAN", "Midi"
Falcon      :   "Modem 1", "Modem 2", "LAN", "Midi"
Note that you need to do a little hardware work to be able to use
Modem 1 on a Falcon. The Falcon port that is labeled "Modem" on the
case is "Modem 2".

If this driver is to be used under a TOS version that does not support
Bconmap() in XBIOS (if you use a TOS 1.x then this is most probably
the case) then HSMODEM or an equivalent package *must* be installed.
To check for this, simply have STinG load this driver, and look into
the STNGPORT.CPX, or run ConfSTinG from the desktop, or check whether
Modem 1 is there. Modem 1 should be shown available on every machine,
even the Falcon. If it isn't on yours, you must install HSMODEM.

If you want to use Midi for serial point to point networking then you
must install HSMODEM too. Note that you won't find a Midi entry in
STNGPORT.CPX or ConfSTinG if you haven't got HSMODEM installed. Do not
confuse this with MidiNet, which is a Midi based ring network that
brings it's own driver, as HSMODEM MIDI.PRG can't be used for it.

If HSMODEM is used on a TT or Mega STE to control the SCC ports
("Modem 2" and "Ser.2/LAN") then the HSMODEM SCC.PRG variable "LANBIT"
should be set to "Yes".

@endnode


@node "CEN_PLIP.STX : Connect Networks Instead of Printers"
CEN_PLIP.STX : Connect Networks Instead of Printers                STinG
@xref "cen_plip.hyp/Main" "CEN_PLIP.STX"
@line 1 72 0 0 7

This module is not available yet for this kernel version.

@endnode


@node "ETHER.STX : Heyyya, This is Fast !"
ETHER.STX : Heyyya, This is Fast !                                 STinG
@line 1 72 0 0 7

This module only contains dummy code as yet. I'm working on a module
supporting LANCE based Ethernet adapters.

@endnode


@node "MIDI.STX : Musical Networking"
MIDI.STX : Musical Networking                                      STinG
@line 1 72 0 0 7

This module only contains dummy code as yet. I always wanted to do
real networking with the Atari's Midi ports, by connecting many
machines in a ring shaped network. No time to work on it right now,
though.

@endnode


@node "LCLTLK.STX : Atari Bites the Apple"
LCLTLK.STX : Atari Bites the Apple                                 STinG
@line 1 72 0 0 7

This module only contains dummy code as yet. It's been an early
suggestion by Dan Ackerman. Nobody is working on it right now.

@endnode


@node "MASQUE.STX : Carnival on the Net"
MASQUE.STX : Carnival on the Net                                   STinG
@xref "masque.hyp/Main" "MASQUE.STX"
@line 1 72 0 0 7

 Documentation for Masque.Stx version 1.15
 Created by Ulf Ronald Andersson

 @{U}Contents@{u}

 @{"Introduction to Masque" LINK "Masque : Introduction"}
 @{"Installation of Masque" LINK "Masque : Installation"}
 @{"Configuring Masque" LINK "Masque : Configuration"}

 @{"Masque tool programs" LINK "Masque tool programs"}
 @{"Masque cntrl_port interface" LINK "Masque cntrl_port interface"}
 @{"Masque Development History" LINK "Masque : Development History"}
 @{"Masque Feedback" LINK "Credits and Copyright"}
@endnode


@node "Masque : Introduction"
Masque : Introduction                                              STinG
@line 1 72 0 0 7

Masque.Stx is a STinG module which implements IP masking, so that all of the
computers on a local network can access internet through a single connection
of one of them.  More than one of those computers may have Masque installed,
but only linked to ports that are either passive, or connected to internet
(or another intranet).

For example:

I only have one reasonably fast modem (and only one phoneline), and that is
normally connected to my TT030.  I also have a Falcon030 and a Mega ST4, none
of which have a modem.  These computers are connected as a STinG network and
can all access Internet at the same time, thanks to Masque which is running on
the TT030.  All normal STiK/STinG clients work well with this setup, including
CAB, Newsie, PopWatch, etc...

However:

For technical reasons there are a few operations that can not work with the
current Masquerade methods, but normally those operations can be replaced by
other means, simply by reconfiguring the client programs.  For example, the
FTP command "PORT" will not work, but all FTP clients can instead use the
FTP command "PASV" instead, and some of them do that by default anyway.

Incoming requests from clients on Internet to servers running in your local
network can only be handled by one of the local machines.  Normally that is
the machine with the modem, where Masque is active, but this can be changed.

From version 1.15 of Masque it has the ability to treat any local machine
as its 'master'.  A special tool program is included, which will send Masque
a 'master switch' request.  When Masque receives that message it will switch
to regarding the system it came from as the new 'master' machine, which will
thus be able to service requests from Internet, as well as local requests.
@endnode


@endnode


@node "Masque : Installation"
Masque : Installation                                              STinG
@line 1 72 0 0 7

1:  Copy MASQUE.STX to your STinG STX collection folder on the machine used
    for connecting to the Internet (preferably one with a fast modem port).

2:  Configure masquerading as described in the section  @{"Configuring Masque" LINK "Masque : Configuration"}

That's it...
@endnode


@node "Masque : Configuration"
Masque : Configuration                                             STinG
@line 1 72 0 0 7

Configuring Masque has recently become a lot easier,  because it is fully
supported by the STinG Dialer.  This means that you do not need to change
the ROUTE.TAB file to add a Masquerade entry any more. Instead the Dialer
will edit the corresponding route tables in  memory,  as and when needed,
including restoring the routes  after disconnecting.  Thus you can forget
this aspect of Masque configuration from now on.

Even so, to get any benefit from Masque you must have a functional local
network with properly defined ROUTE.TAB files on each of its machines.

Here are some examples and important rules concerning this:

I use the Midi and Plip drivers for local networks and my subnet route
(on a line above the default route) for Midi looks like this:
1.1.2.0     255.255.255.0   Midi        0.0.0.0

On each of the computers using this subnet I have set up the Midi ports
to use the IP addresses 1.1.2.x, with 'x' standing for an arbitrary
machine number unique to each computer in the subnet.

The IP addresses will only be used locally, which is why you can choose
arbitrarily,  but if you use any that correspond with real addresses on
Internet you will  not be able to access those real addresses even when
connected to Internet, since STinG's router will use the local ones.

On a very simple network the machines not connected to the dial-up modem
can manage with a single default route allowing them to reach the modem-
connected machine, and such a route should then look like this:
0.0.0.0     0.0.0.0     Midi        0.0.0.0

But the modem-connected machine _must_ have the local route defined as a
subnet  (see further above)  since its default route after  dial-up will
lead to Internet  (via Masquerade port and modem port).  If you only use
a  default route on this machine too,  then contact with the other local
machines will be lost during dial-up connections.

And remember that default routes (with all those zeroes) must be placed
after any  subnet route definitions,  because  routing is done from the
top down in ROUTE.TAB,  so stuff below the default route is never used.

Using a simple default route without other subnets,  like above,  means
that all packets addressing ports on other computers  will be sent over
Midi in the hope that whoever receives it will be able to pass it on to
someone else etc, in such a way that it eventually does reach the final
recipient through an unknown number of intermediaries.

This routing is naturally done in the same way,  regardless of whether
the packets originated on the local machine or arrived on some port...

In case you didn't know it, this is what IP networking is all about.  ;-)

(Don't laugh guys!  Many smart Internet users have no idea how it works.)


Masque itself is implemented as a STinG port driver, and will therefore
appear in the port list of STNGPORT.CPX, and is configurable from any
modern version of this, or of the dialer.  Modern here means STinG
release 1.08 from late 1997, but newer releases have been made since,
so get those to make sure you have the latest and best drivers.

Settings in the Dialer as usual override any CPX settings when Dialer
establishes a connection, so normally the pseudo port 'Masquerade'
should not be enabled 'manually' in STNGPORT.CPX .  Instead you should
select masquerading in the 'Miscellaneous' section in the 'Configs'
dialog of the Dialer.

Having installed Masque.Stx properly,  you must of course still reboot
the system so as to load the new module in order to configure it. This
can not be done properly without having STinG load it first,  so do it
before proceeding.

Actually you do not need to alter any of the data of the  "Masquerade"
port, because it is written so as to provide sensible defaults for its
settings.  Even so, you should open the CPX and save the settings,  so
they will be included in the STING.PRT file with data for other ports.

The settings include 2 purely local IP addresses, that are used in the
masking work.  Their defaults are  "10.0.255.0" and "10.0.255.1".  The
former is used to mask the  physical port,  while the latter is the IP
address of the Masquerade pseudo port itself. The defaults were chosen
as suggested by  Peter  Rottengatter,  because they can't exist on the
Internet.

Another setting is the max MTU size, with a default of 1500,  which is
a value that should work well with most providers.

Finally there is the choice of port to be masked, which you can set
to be the Modem port that you use.

NB: Let me emphasize again that at dial-up the settings of the Dialer
    will override any settings of the CPX, so you must also make sure
    to save settings into the DIAL.SCR file after editing them in the
    'Configs' dialog in the Dialer.


Once the system has been rebooted with proper 'Masque' setup, and dialer
has established an ISP connection, Masque will take partial control of
the selected port, acting as a filter between it and the internal STinG
functions.  Masque will also 'steal' the IP number of that port whenever
it changes, so dynamic IPs of all kinds should work fine.

Since Masque is a simulated port all data will pass through a physical
port too before reaching the internet, and the MTU value of both ports
should be identical for efficiency reasons and must of course _never_
exceed the maximum MTU value your ISP allows.


NB: An error simple to make is to use STNGPORT.CPX to manually activate
    Masquerade or the  Modem port it should interact with.  This is not
    the proper way to do it !!!  They should always be left passive, so
    for that reason you should never save STING.PRT while connected.
    The CPX  (and its STING.PRT file)  should only be used to  activate
    ports that are intended for LAN usage, not ISP dial-up connections.
    The dialer will activate those as needed when correctly configured.

    Note that the above rule applies even without Masquerade.  It is at
    all times the dialer that should activate any port used for dial-up
    connection to an ISP.
@endnode


@node "Masque tool programs"
Masque tool programs                                               STinG
@line 1 72 0 0 7

Two extra tool programs are included in the Masque package, and they are:

        MASQLOOK.APP    used to display the true IP a masked connection
        M_MASTER.APP    used to switch 'master' machine in masquerade


MASQLOOK is only useful on the machine where Masqe is active, and it will
simply display an alert box stating whether the masquerade port is active
or not, and if active also stating what the real IP address of the masked
port was before it became masked.  In normal modem connections this means
that it will show the true dynamic or static IP address with which you are
logged on to the Internet, and which other users on Internet must use when
they want to contact servers on your machine directly.  If Masque is not
active, or not even present, then that will be displayed in the alert box
instead.


M_MASTER can be used on any machine in your local network, and it will
then send a special 'Masquerade Master' request through the default
route.  When such a route leads (as it eventually should) to the machine
where Masque is active, then Masque will switch to regarding the sender
as the machine that can interact directly with Internet. It is then that
machine that will be able to receive incoming requests from the Internet,
and which will be able to send certain commands to the Internet that the
other local machines can not do (but they can still use normal commands).
The program will display an alert box stating whether the attempt to set
the new 'Master' succeeded or failed.  If it succeeded, then the true
IP with which you are logged on to the Internet is also shown, just as
for MASQLOOK above.

Note that Masque.Stx will set up the modem machine as 'master' whenever
a dialup connection is made.  To have another machine as 'master' it is
necessary to run M_MASTER on that machine after each dialup.
(ie: After successful completion of the IP link.)


The reason for having both tools is that they use different methods of
finding Masque.  MASQLOOK simply asks STinG to give it the data for the
local copy of Masque (if any).  M_MASTER on the other hand just sends
a packet, hoping that it will reach an active Masque on another machine
which will then send a reply.  The difference is that if anything is
wrong with the routing on any machine in the LAN, then the request or
its reply may get lost, and if Masque is either inactive or missing
then no specific reply will be sent anyway.
@endnode


@node "Masque cntrl_port interface"
Masque cntrl_port interface                                        STinG
@line 1 72 0 0 7

STinG now has a new API function to access and control ports and as Masque
is implemented as a port, its driver does support that new function.  The
supported 'cntrl_port' opcodes are the following:

CTL_GENERIC_SET_IP      =>      Set IP number of Masquerade port
CTL_GENERIC_GET_IP      =>      Get IP number of Masquerade port
CTL_GENERIC_SET_MTU     =>      Set MTU size of Masquerade port
CTL_GENERIC_GET_MTU     =>      Get MTU size of Masquerade port
CTL_GENERIC_GET_MMTU    =>      Get Max MTU size of Masquerade port
CTL_GENERIC_GET_TYPE    =>      Get port link type of Masquerade port
CTL_GENERIC_GET_STAT    =>      Get port transfer statistics
CTL_GENERIC_CLR_STAT    =>      Clear port transfer statistics

CTL_MASQUE_SET_PORT     =>      Set ptr to masked port struct
CTL_MASQUE_GET_PORT     =>      Get ptr to masked port struct
CTL_MASQUE_SET_MASKIP   =>      Set IP address to be used for masking
CTL_MASQUE_GET_MASKIP   =>      Get IP address to be used for masking
CTL_MASQUE_GET_REALIP   =>      Get IP address which is being masked

These functions are very tolerant of input data, so they accept almost any
values, even if these will not give functional results.  This means it is
the responsibility of the calling program to avoid nonfunctional values !

Error codes possible:

E_PARAMETER will result if anyone calls the cntrl function in the driver
without setting up the port pointer like the kernel does.  That will not
happen if you call the 'cntrl_port' API function correctly, because then
the kernel will find the port structure itself. (You use the port name.)

E_PARAMETER will result if CTL_GENERIC_SET_MTU is called with an MTU value
that is higher than the maximum allowed for the port (8192).

E_UNREACHABLE will result if CTL_MASQUE_GET_REALIP is called when the port
is not active.  Since no masking is done then, no masked IP can exist.

E_FNAVAIL will result if any opcode other than those listed above are used.

A small utilitily program named MASQLOOK.APP is supplied with the Masque
driver, which uses the cntrl_port functions to see if Masque is active
and which 'real IP' it is then masking.  This can be useful to know when
you want someone on Internet to access local servers on your LAN machines.
@endnode


@node "Masque : Development History"
Masque : Development History                                       STinG
@line 1 72 0 0 7

@{U} Version 1.15   1999.11.03 @{u} Public release: 2000.07.05

    This version was released with the STinG 1.26 release package.
    It contains some internal changes, mainly to allow TCP and UDP
    servers to function better when serving clients on the Internet.
    In most other respects it works the same way as older versions.


@{U} Version 1.14   1998-1999 @{u}

    I performed various experiments with this version(s), but none
    that were released to the public.


@{U} Version 1.13   1998 October 18 @{u}

    Version 1.12 had a bug that prevented proper TCP operation over
    masqueraded connections.  This was due to a mistranslation of
    some constant definitions for TCP header structures and that in
    turn was due to some differing syntax rules of DevPac VS Pasm.

    This problem has now been fixed, so version 1.13 now works as
    well as version 1.11 did. It is however suitable for use only
    with the new STinG versions from 1.20 and on, whereas Masque
    version 1.11 is suitable for use only with older STinG versions.


@{U} Version 1.12   1998 September 8 @{u}

    Added the new driver structure element 'cntrl' used by the kernel
    to implement the new 'cntrl_port' API function.  A call dispatcher
    was also added to support a number of 'cntrl_port' opcodes. This
    is a big change, but an even bigger one is that the source has now
    been converted to DevPac dialect, as has all the support libraries.
    The actual masquerade methods remain unchanged from version 1.11 .


@{U} Version 1.11   1998 March 2 @{u}

    Added a new port structure element holding the masked IP, which is
    normally the ISP dial-up IP needed by some clients for some special
    transfer protocols.  This means it is now possible to find that
    address by careful access of the port structure.  A tool program,
    MasqLook.APP (renameable to ACC/TOS etc) is supplied that uses
    this to present the IP address as text on screen, so that a user
    can pass this to clients etc.  For frequent use I recommend using
    it as an ACC, but for less frequent use I suggest keeping it an APP.


@{U} Version 1.10   1998 January 13 @{u}

    Masking methods modified to allow local servers to be contacted
    by clients on the Internet.

    Hypertext was amended to describe usage with latest STinG.


@{U} Version 1.09   1997 October 25 @{u}

    Added module basepage pointer to DRIVER structure.
    This is a new standard defined to ease debugging.


@{U} Version 1.08   1997 September 7 @{u}

    Partial ICMP support added for 3 (of 6) message classes:

        Incoming error messages for UDP and TCP connections
        Outgoing ICMP requests (echo, timestamp, etc)
        Incoming ICMP replies (echo, timestamp, etc)

    The types now supported are sufficient for the normal PING
    and TRACEROUTE implementations, and tests with those tools
    as implemented both in the dialer and in separate programs
    in the  STinG  release verify this.  All these now work in
    the same way with Masquerade as they do without it.

    The following three message classes are not yet supported,
    and such packets will still merely be dropped and ignored:

        Outgoing error messages for UDP and TCP connections
        Incoming ICMP requests (echo, timestamp, etc)
        Outgoing ICMP replies (echo, timestamp, etc)

    Of those only the first is of any real interest, since the
    others will never occur on a normal ISP connection.

    Undefined/Future ICMP message types are also ignored, which
    is the recommended treatment of such enhancements when they
    can not be properly supported.

    The hypertext was reworked a bit for improved readability,
    and extended with some clues on how to set up a functional
    LAN, for those who are not yet familiar with this aspect
    of STinG.  (Suggested by beta tester Eabe Kuik.)


@{U} Version 1.07   1997 August 21 @{u}

    Port illegality test added, as suggested by Peter


@{U} Version 1.06   1997 August 21 @{u}

    Change of default IP numbers, as suggested by Peter


@{U} Version 1.05   1997 August 20 @{u}

    Bug correction of mislinked masquerade queues


@{U} Version 1.04   1997 August 19 @{u}

    Update for longer port name "Masquerade" requested by Peter


@{U} Version 1.03   1997 August 18 @{u}

    Update for new STinG port type implemented by Peter in
    STNGPORT.CPX and Dialer.


@{U} Version 1.02   1997 August 18 @{u}

    Update for new configuration method suggested by Peter.
    Documentation converted to hypertext.


@{U} Version 1.01   1997 August 14 @{u}

    Update for unblocking time limitation on mask/unmask work


@{U} Version 1.00   1997 August 12 @{u}

    First functional release (to me and Peter only)


@{U} Version 0.xx   1997 August 10-12 @{u}

    Project start and various pre-release experiments

@endnode


@node "TCP.STX : Transmission Control Protocol"
TCP.STX : Transmission Control Protocol                            STinG
@line 1 72 0 0 7


@endnode


@node "UDP.STX : User Datagram Protocol"
UDP.STX : User Datagram Protocol                                   STinG
@line 1 72 0 0 7


@endnode


@node "RESOLVE.STX : The DNS-Resolver"
RESOLVE.STX : The DNS-Resolver                                     STinG
@line 1 72 0 0 7

 Documentation for Resolve.Stx version 1.06
 Created by Ulf Ronald Andersson

 @{U}Contents@{u}

 @{"Introduction to the DNS-Resolver" LINK "Resolver : Introduction"}
 @{"Resolver Command List" LINK "Resolver : Command List"}
 @{"Resolver Development History" LINK "Resolver : Development History"}
 @{"Resolver Feedback" LINK "Credits and Copyright"}

@endnode


@node "Resolver : Introduction"
Resolver : Introduction                                            STinG
@line 1 72 0 0 7

Most TCP/IP client programs allow the user to type in IP addresses in the form
of symbolic domain names or numeric (dotted IP) addresses. These are then used
as an argument in calling the resolver module to gain the missing information.
By using a command syntax  illegal for either  symbolic or  numeric addresses,
my resolver module allows such interfaces to be used for commands as well.

The recommended method to use these commands is to do so through the 'Resolve'
tool of the STinG dialer program written by  Peter  Rottengatter.  Using other
client interfaces should also work but may have side effects in those programs.
(Usually causing connection attempts to the IP addresses of stored entries.)

All command keywords begin and end with square brackets ('[' and ']'), and any
unknown sequence starting with a left square bracket will have no effect,  but
will cause the resolver to return the  error code 'E_CANTRESOLVE'.  That  code
will also be returned for any commands that fail, regardless of actual causes.

The reason for this is that some clients test for that error code only.  These
would attempt to use some garbage data if I use another error code, with bombs
resulting from that attempt.  All successful commands will resolve some  cache
entry on completion, to provide a visible indication of the success.  The only
exceptions are [FIRST] and [NEXT] when used so as to get a nonexistent entry.
That will naturally return E_CANTRESOLVE, though there was no real failure.

Blank characters (Tabs and spaces) will be ignored both around and between all
keywords, arguments and separators, but may not be used within such units.

NB: Here period signs ('.') are not considered as unit separators, but rather
    as operators, building full addresses and names from substrings.  Domain
    names and dotted IP numbers are not allowed any internal blanks.
    The only separators currently defined are '=' and ':'

Within the square brackets of a command character case is neither preserved
nor significant, so "[LOAD]" does the same as "[load]" or even "[LoAd]" etc.

@endnode


@node "Resolver : Command List"
Resolver : Command List                                            STinG
@line 1 72 0 0 7

Command list:       Six commands are defined at present

[LOAD]      no argument Loads the CACHE.DNS file into RAM from disk
[SAVE]      no argument Saves the CACHE.DNS file from RAM onto disk
[FIRST]     no argument Resolves the root entry of DNS RAM cache
[NEXT]      no argument Resolves the next entry of DNS RAM cache
[CNAME] arg1 = arg2 : arg3  Defines a canonical domain name for an IP
[ALIAS] arg1 = arg2 : arg3  Defines an alias domain name for an IP

The last two commands have identical syntax and the meaning of argument is:

arg1    The domain name.    eg: hugin.oden.se   (My ISP's main server)
arg2    The dotted IP.      eg: 193.45.240.2    (IP number of the same)
arg3    Time To Live (seconds)  eg: 172800      (valid for two days)

The TTL entry and the preceding ':' are optional, and if excluded a default of
10 years will be used. This is intended for entry of semi-permanent IP numbers
on your local networks, and  allows fully symbolic addresses to be used on any
small  intranet as well as on internet.  No nameserver is needed for this, and
that is important since none is available under TOS as yet.

NB: In order to define an alias, you must *FIRST* define the canonical name of
    that IP number.  Aliases are linked in via the canonical entries, so those
    must exist first.  (This is handled automatically for network queries.)

The two commands [FIRST] and [NEXT] can be used to scan through all entries of
the cache since E_CANTRESOLVE is returned as the end of the cache is reached.

For technical reasons FIRST here means the latest defined CNAME, and the last
entry will be the oldest ALIAS of the oldest CNAME, or that CNAME itself if
the oldest one does not have any aliases.  This is how the cache is organized,
and the scanning order follows this pattern consistently.  Thus aliases are
defined relative to their CNAME, and the order in which they were defined
also relates only to the other aliases of the same CNAME.

Command results as returned to the resolving client program:

keyword     Results
-------     -------
[LOAD]      Resolves the 'root' entry of successfully loaded cache
[SAVE]      Resolves the 'current' entry of the cache on successful save
[FIRST]     Resolves the 'root' entry of the cache, unless it is empty
[NEXT]      Resolves the 'next' entry of the cache, unless already at end
[CNAME]     Resolves the entry defined, if that succeeds
[ALIAS]     Resolves the entry defined, if that succeeds

NB: For safety reasons given in the introduction, all failures of the commands
    will be returned to the calling client as the error code  'E_CANTRESOLVE'.
    That is the only code which ensures that no erroneous data will be used as
    if it was valid, which could lead to 'bombs'.

NB: Since most clients will attempt to make some use of each resolved address,
    I strongly suggest that only the STinG dialer's 'Resolve' tool be used to
    enter the commands.  That is the only client I know of which will never
    use the so resolved addresses on the network.

@endnode


@node "Resolver : Development History"
Resolver : Development History                                     STinG
@line 1 72 0 0 7

Version     Major changes from last version
-------     -------------------------------

  1.06      Modified [NEXT] to recognize cache end in user scans
97.09.24    Fixed bug returning E_NOMEM on RAM error to use E_CANTRESOLVE
        Fixed bomber bug in cache that struck ALIASes without CNAMEs
        Added multiple IP return to network DNS queries
        Added multiple caching for DNS queries with multiple results
        Added multiple IP return to DNS cache queries
        Added ICMP error message response, so all LAN machines notice
          when DNS requests to ISP fail due to offline state

  1.05      Removed case sensitivity from command word interpreter
97.09.12    Restructured some caching code

  1.04      Fixed some command bugs
97.08.06    Fixed some caching bugs
        Changed local name ttl default to eternity, to avoid losing
          entries when starting without proper time set.

  1.03      First proper release
97.06.??    Implemented cache commands
        Fixed various bugs
        Restructured some DNS query code

  1.02      First functional version
97.05.??    Combined caching with network queries
        Implemented UDP retries with TCP fallback

 0.00-1.01  Early experimental versions, first by Peter then later by me
  various   These included separately developed code for network queries
        and for the basic cache system (still largely retained).

@endnode
